<!DOCTYPE html><html lang="ja"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>TOTP をフルスクラッチした | blog.comame.xyz</title><meta property="og:type" content="article"/><meta property="og:url" content="https://blog.comame.xyz/entries/2020-07-20/implement-totp-in-js.md"/><meta property="og:title" content="TOTP をフルスクラッチした | blog.comame.xyz"/><meta property="og:site_name" content="blog.comame.xyz"/><meta property="og:description" content=""/><meta name="description" content=""/><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/75b3a985ae8df8a5857d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/75b3a985ae8df8a5857d.css"/><link rel="preload" href="/_next/static/css/7e552a05a23ef38b9280.css" as="style"/><link rel="stylesheet" href="/_next/static/css/7e552a05a23ef38b9280.css"/><link rel="preload" href="/_next/static/chunks/main-f01cf1dcca173d7f43b1.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-ccf5ab034a524403276a.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ea5d6f7a7099b14097ba.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.136473f176143783e714.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-7826aa35c5692e1bca69.js" as="script"/><link rel="preload" href="/_next/static/chunks/44192d0b83adb4471c56c08528820b1f17270e33.228b4631e982fe3bd0c5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/entries/%5Bdate%5D/%5Bid%5D-217160f5fe64bb279c4b.js" as="script"/></head><body><div id="__next"><header class="header_header__10AWY"><a href="/">blog.comame.xyz</a></header><div class="post"><div class="metadata_metadata__3aUvp"><h1 id="title">TOTP をフルスクラッチした</h1><time id="time">2020-07-20</time><ul class="tag-list_tag-list__1Wf57"><li><a href="/tags/note.html">note</a></li></ul></div><div class="content_content__3lhGG"><p>JavaScript で TOTP を実装してみたので、その実装メモなど。</p>
<p><a href=https://github.com/comame/TOTP target='_blank' rel='noopener'>https://github.com/comame/TOTP</a></p>
<h2>TOTP</h2>
<p>RFC 6238: TOTP: Time-Based One-Time Password Algorithm で規定される。Google Authenticator アプリなどを使って時刻ベースで生成される (大抵) 6 桁のワンタイムパスワードであり、2 要素認証に用いられる。</p>
<p>疑似コードで次のように表される。</p>
<pre>
<code>K: 共有シークレット、QR コードとかで読み込むやつ</code>
<code>X: ステップ秒。大抵 30 秒。この値の周期でトークンが切り替わる</code>
<code>T0: Unix Time の開始秒。大抵 0</code>
<code></code>
<code>T = (Current Unix Time - T0) / X) as Integer</code>
<code></code>
<code>TOTP(K, T) = HOTP(K, T) = Truncate(HMAC-SHA-1(K, T))</code>
</pre><p>トークンの生成アルゴリズムには HOTP を使用する。</p>
<p>のちに記述するように、HOTP では T の値が 32-bit までしかサポートされていないため、4.2 節では 32-bit より大きい整数をサポートするように規定されている。具体的にどう実装するのかは記述されていないので、Google Authenticator の実装などを見るのが良いと思われる。</p>
<h2>HOTP</h2>
<p>RFC 4226: HOTP: An HMAC-Based One-Time Password Algorithm で規定される。カウンターベースのワンタイムパスワード。</p>
<pre>
<code>K: 共有シークレット</code>
<code>C: カウンター。8-byte の整数</code>
<code>HS: 20-byte</code>
<code>S: 31-bit</code>
<code>D: 桁数が Digit の HOTP トークン</code>
<code></code>
<code>DT(HS: bytes[20])</code>
<code>    OffsetBits = HS[19] & 0xF // HS[19] の下位 4-bit</code>
<code>    Offset = OffsetBits as Integer // 0 <= offset<= 15</code>
<code>    P = HS[Offset]...HS[Offset + 3]</code>
<code>    return P & 0x7FFFFFFF // 下位 31-bit</code>
<code></code>
<code>HS = HMAC-SHA-1(K, C)</code>
<code>S = DT(HS)</code>
<code>D = (S as Integer) mod 10^Digit</code>
</pre><p>RFC の 5.4 節の例は次の通りである。</p>
<pre>
<code>HS = {</code>
<code>    1F, 86, 98, 69, 0E,</code>
<code>    02, CA, 16, 61, 85,</code>
<code>    50, EF, 7F, 19, DA,</code>
<code>    8E, 94, 5B, 55, 5A</code>
<code>}</code>
<code></code>
<code>OffsetBits = 0xA</code>
<code>Offset = 10</code>
<code>P = 0x50EF7F19</code>
<code></code>
<code>S = 0x50EF7F19 & 0x7FFFFFFF = 0x50EF7F19</code>
<code>D = 872921</code>
</pre><h2>HMAC</h2>
<p><a href=https://www.ipa.go.jp/security/rfc/RFC2104JA.html target='_blank' rel='noopener'>https://www.ipa.go.jp/security/rfc/RFC2104JA.html</a> に日本語での解説がある。</p>
<pre>
<code>H: ハッシュ関数</code>
<code>K: シークレット</code>
<code>M: メッセージ</code>
<code></code>
<code>ipad = 0x3636...</code>
<code>opad = 0x5C5C...</code>
<code>// ipad, opad の長さはハッシュ関数のブロック長 (SHA-1 の場合 512-bit) と同一</code>
<code></code>
<code>||: ビットの連結</code>
<code></code>
<code>HMAC(K, M) = H((K xor opad) || H((K xor ipad) || M))</code>
</pre><p>K と opad, ipad とで排他的論理和をとっていることから分かるように、K の長さもハッシュ関数のブロック長と同一にする必要がある。K は入力値であることから、長さを揃えるために次のような処理を順に行う。</p>
<p>K の長さがブロック長より大きい場合、K をハッシュ関数に通す。K の長さがブロック長より小さい場合、ブロック長と同一になるまで末尾に 0 を追加する。</p>
<h2>SHA-1</h2>
<p><a href=https://www.ipa.go.jp/security/rfc/RFC3174JA.html target='_blank' rel='noopener'>https://www.ipa.go.jp/security/rfc/RFC3174JA.html</a> に日本語での解説がある。</p>
<p>まずはメッセージのパディングを行い、メッセージ長を 512-bit の倍数にする。オリジナルのメッセージ長が 512-bit の倍数であった時にもパディングは行う。パディングは次の手順で行う。</p>
<ul>
<li>末尾に 1-bit の 1 を付加する</li>
<li>メッセージ長が mod 512-bit = 448 になるまで 0 を末尾に付加する</li>
<li>オリジナルのメッセージ長を 64-bit で付加する</li>
</ul>
<p>次の関数を定義する。</p>
<pre>
<code>f(t; B, C, D) = (B & C) | ((~B) & D); (0 <= t <= 19)</code>
<code>f(t; B, C, D) = B ^ C ^ D; (20 <= t <= 39)</code>
<code>f(t; B, C, D) = (B & C) | (B & D) | (C & D) (40 <= t <= 59)</code>
<code>f(t; B, C, D) = B ^ C ^ D; (60 <= t <= 79)</code>
<code></code>
<code>K(t) = 0x5A827999; (0 <= t <= 19)</code>
<code>K(t) = 0x6ED9EBA1; (20 <= t <= 39)</code>
<code>K(t) = 0x8F1BBCDC; (40 <= t <= 59)</code>
<code>K(t) = 0xCA62C1D6; (60 <= t <= 79)</code>
<code></code>
<code>S^N(n) = (M << n) | (M >> (32 - n)) // 循環左シフト</code>
<code>A + B = (A + B) mod (2 ** 32)</code>
</pre><p>複数の計算方法があるようだが、今回は次の方法で計算した。</p>
<pre>
<code>M: 512-bit ごとに区切ったメッセージ</code>
<code></code>
<code>H0 = 0x67452301</code>
<code>H1 = 0xEFCDAB89</code>
<code>H2 = 0x98BADCFE</code>
<code>H3 = 0x10325476</code>
<code>H4 = 0xC3D2E1F0</code>
<code></code>
<code>for each M(i)</code>
<code>    W[16] = M(i) // M(i) を 32-bit ごとに分割する</code>
<code></code>
<code>    for t from 16 to 79</code>
<code>        W[t] = S^1(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16])</code>
<code></code>
<code>    A = H0; B = H1; C = H2; D = H3; E = H4</code>
<code></code>
<code>    for t from 0 to 79</code>
<code>        TMP = S^5(A) + f(t; B, C, D) + E + W[t] + K(t)</code>
<code>        E = D; D = C; C = s^30(B); A = TMP</code>
<code></code>
<code>    H0 += A; H1 += B; H2 += C; H3 += D; H4 += E</code>
<code></code>
<code>// H0 H1 H2 H3 H4 をこの順で並べる</code>
</pre><h2>実装で苦しんだところ (大体うっかり)</h2>
<h3>HOTP</h3>
<p>C は 8-byte 整数。</p>
<h3>HMAC</h3>
<p>ハッシュ関数に SHA-1 を使用する場合、ブロック長は 64-byte、出力長は 20-byte であることから、K にハッシュを通した後に 0 を追加する処理を行う必要がある。</p>
<h3>SHA-1</h3>
<p>(追記あり) 左循環シフト。<code>(n: number, x: number) =&gt; (x &lt;&lt; n) | (x &gt;&gt; (32 - n))</code> と素直に書くと、x は 32-bit 整数、<code>0 &lt;= n &lt; 32</code> であることからオーバーフローする。</p>
<h2>参考にしたもの</h2>
<dl>
    <dt>IPA の RFC 日本語訳</dt>
    <dd>HMAC と SHA-1 の実装</dd>
    <dt>Golang のソースコード</dt>
    <dd>テストケースや各アルゴリズムの実装。読みやすい。</dd>
    <dt>RFC</dt>
    <dd>テスト用のサンプルケースが Appendix に書いてあることを初めて知った</dd>
</dl>


<h2>左循環シフトの高速化</h2>
<p><a href=https://github.com/comame/TOTP/compare/e495732d9156e805c78ff2626e95f09301123b32...361549fc64a207bcc402f48f802ee4d68b61cac6 target='_blank' rel='noopener'>https://github.com/comame/TOTP/compare/e495732d9156e805c78ff2626e95f09301123b32...361549fc64a207bcc402f48f802ee4d68b61cac6</a></p>
<p>オーバーフローをしないためにビットの配列に変換してシフト操作をしていたものを、number のまま計算できるように書き換えた。オーバーフローを起こさないため、32-bit 整数を 8-bit ずつに区切り、場合分けした。また、シフト演算子を使うとオーバーフローを起こすため、掛け算と割り算でシフト演算子と同等の計算を行うようにした。</p>
<p>次のようなコードで 10 回ずつ計測しそれぞれ平均をとったところ、高速化前は 616 ms、高速化後は 5 ms となった。</p>
<p>また、SHA-1 の計算自体も、おおむね半分から 5 分の 1 程度の実行時間に短縮された。</p>
<pre>
<code>const t = Date.now()</code>
<code>for (let i = 0; i < 100000; i +=1) circularShift(16, 0x12345678)</code>
<code>console.log(Date.now() - t)</code>
</pre><pre>
<code>測定結果</code>
<code></code>
<code>高速化前 [ms]</code>
<code>    608 605 611 598 612 599 698 605 612 611</code>
<code>高速化後 [ms]</code>
<code>    4   4   6   4   5   5   5   4   5   5</code>
</pre></div><div class="share_share__2h1cH"><img alt="共有" src="/icons/share.svg"/><a rel="noopener" target="_blank" title="Twitter で共有" href="https://twitter.com/intent/tweet?text=TOTP%20%E3%82%92%E3%83%95%E3%83%AB%E3%82%B9%E3%82%AF%E3%83%A9%E3%83%83%E3%83%81%E3%81%97%E3%81%9F%0a&amp;url=https%3A%2F%2Fblog.comame.xyz%2Fentries%2F2020-07-20%2Fimplement-totp-in-js.md&amp;related=comameito"><img alt="Twitter で共有" src="/icons/twitter_logo.svg"/></a><a rel="noopener" target="_blank" title="Facebook で共有" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fblog.comame.xyz%2Fentries%2F2020-07-20%2Fimplement-totp-in-js.md"><img alt="Facebook で共有" src="/icons/facebook_logo.svg"/></a><a title="URL をコピー" id="url-copy"><img alt="URL をコピー" src="/icons/link.svg"/></a><script async="" src="/js/url-copy.js"></script></div></div><footer class="footer_footer__cDy4s"><small><a href="https://github.com/comame/blog.comame.xyz" target="_blank" rel="noopener"><img alt="GitHub Actions build status" id="build-status" src="https://github.com/comame/blog.comame.xyz/workflows/Build/badge.svg?event=push"/></a></small><small><span>Copyright 2020 <a href="https://comame.xyz">comame</a></span><span><a target="_blank" rel="noopener" href="https://github.com/comame/blog.comame.xyz/blob/master/archives/2020/implement-totp-in-js.md">source</a></span><span><a target="_blank" rel="noopener" href="https://github.com/comame/blog.comame.xyz/commits/master/archives/2020/implement-totp-in-js.md">history</a></span><span><a href="/feed.xml">Feed</a></span></small></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"entry":{"entry":"implement-totp-in-js","title":"TOTP をフルスクラッチした","date":"2020-07-20","tags":["note"],"type":"md"},"text":"\u003cp\u003eJavaScript で TOTP を実装してみたので、その実装メモなど。\u003c/p\u003e\n\u003cp\u003e\u003ca href=https://github.com/comame/TOTP target='_blank' rel='noopener'\u003ehttps://github.com/comame/TOTP\u003c/a\u003e\u003c/p\u003e\n\u003ch2\u003eTOTP\u003c/h2\u003e\n\u003cp\u003eRFC 6238: TOTP: Time-Based One-Time Password Algorithm で規定される。Google Authenticator アプリなどを使って時刻ベースで生成される (大抵) 6 桁のワンタイムパスワードであり、2 要素認証に用いられる。\u003c/p\u003e\n\u003cp\u003e疑似コードで次のように表される。\u003c/p\u003e\n\u003cpre\u003e\n\u003ccode\u003eK: 共有シークレット、QR コードとかで読み込むやつ\u003c/code\u003e\n\u003ccode\u003eX: ステップ秒。大抵 30 秒。この値の周期でトークンが切り替わる\u003c/code\u003e\n\u003ccode\u003eT0: Unix Time の開始秒。大抵 0\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003eT = (Current Unix Time - T0) / X) as Integer\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003eTOTP(K, T) = HOTP(K, T) = Truncate(HMAC-SHA-1(K, T))\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eトークンの生成アルゴリズムには HOTP を使用する。\u003c/p\u003e\n\u003cp\u003eのちに記述するように、HOTP では T の値が 32-bit までしかサポートされていないため、4.2 節では 32-bit より大きい整数をサポートするように規定されている。具体的にどう実装するのかは記述されていないので、Google Authenticator の実装などを見るのが良いと思われる。\u003c/p\u003e\n\u003ch2\u003eHOTP\u003c/h2\u003e\n\u003cp\u003eRFC 4226: HOTP: An HMAC-Based One-Time Password Algorithm で規定される。カウンターベースのワンタイムパスワード。\u003c/p\u003e\n\u003cpre\u003e\n\u003ccode\u003eK: 共有シークレット\u003c/code\u003e\n\u003ccode\u003eC: カウンター。8-byte の整数\u003c/code\u003e\n\u003ccode\u003eHS: 20-byte\u003c/code\u003e\n\u003ccode\u003eS: 31-bit\u003c/code\u003e\n\u003ccode\u003eD: 桁数が Digit の HOTP トークン\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003eDT(HS: bytes[20])\u003c/code\u003e\n\u003ccode\u003e    OffsetBits = HS[19] \u0026 0xF // HS[19] の下位 4-bit\u003c/code\u003e\n\u003ccode\u003e    Offset = OffsetBits as Integer // 0 \u003c= offset\u003c= 15\u003c/code\u003e\n\u003ccode\u003e    P = HS[Offset]...HS[Offset + 3]\u003c/code\u003e\n\u003ccode\u003e    return P \u0026 0x7FFFFFFF // 下位 31-bit\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003eHS = HMAC-SHA-1(K, C)\u003c/code\u003e\n\u003ccode\u003eS = DT(HS)\u003c/code\u003e\n\u003ccode\u003eD = (S as Integer) mod 10^Digit\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eRFC の 5.4 節の例は次の通りである。\u003c/p\u003e\n\u003cpre\u003e\n\u003ccode\u003eHS = {\u003c/code\u003e\n\u003ccode\u003e    1F, 86, 98, 69, 0E,\u003c/code\u003e\n\u003ccode\u003e    02, CA, 16, 61, 85,\u003c/code\u003e\n\u003ccode\u003e    50, EF, 7F, 19, DA,\u003c/code\u003e\n\u003ccode\u003e    8E, 94, 5B, 55, 5A\u003c/code\u003e\n\u003ccode\u003e}\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003eOffsetBits = 0xA\u003c/code\u003e\n\u003ccode\u003eOffset = 10\u003c/code\u003e\n\u003ccode\u003eP = 0x50EF7F19\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003eS = 0x50EF7F19 \u0026 0x7FFFFFFF = 0x50EF7F19\u003c/code\u003e\n\u003ccode\u003eD = 872921\u003c/code\u003e\n\u003c/pre\u003e\u003ch2\u003eHMAC\u003c/h2\u003e\n\u003cp\u003e\u003ca href=https://www.ipa.go.jp/security/rfc/RFC2104JA.html target='_blank' rel='noopener'\u003ehttps://www.ipa.go.jp/security/rfc/RFC2104JA.html\u003c/a\u003e に日本語での解説がある。\u003c/p\u003e\n\u003cpre\u003e\n\u003ccode\u003eH: ハッシュ関数\u003c/code\u003e\n\u003ccode\u003eK: シークレット\u003c/code\u003e\n\u003ccode\u003eM: メッセージ\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003eipad = 0x3636...\u003c/code\u003e\n\u003ccode\u003eopad = 0x5C5C...\u003c/code\u003e\n\u003ccode\u003e// ipad, opad の長さはハッシュ関数のブロック長 (SHA-1 の場合 512-bit) と同一\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003e||: ビットの連結\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003eHMAC(K, M) = H((K xor opad) || H((K xor ipad) || M))\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003eK と opad, ipad とで排他的論理和をとっていることから分かるように、K の長さもハッシュ関数のブロック長と同一にする必要がある。K は入力値であることから、長さを揃えるために次のような処理を順に行う。\u003c/p\u003e\n\u003cp\u003eK の長さがブロック長より大きい場合、K をハッシュ関数に通す。K の長さがブロック長より小さい場合、ブロック長と同一になるまで末尾に 0 を追加する。\u003c/p\u003e\n\u003ch2\u003eSHA-1\u003c/h2\u003e\n\u003cp\u003e\u003ca href=https://www.ipa.go.jp/security/rfc/RFC3174JA.html target='_blank' rel='noopener'\u003ehttps://www.ipa.go.jp/security/rfc/RFC3174JA.html\u003c/a\u003e に日本語での解説がある。\u003c/p\u003e\n\u003cp\u003eまずはメッセージのパディングを行い、メッセージ長を 512-bit の倍数にする。オリジナルのメッセージ長が 512-bit の倍数であった時にもパディングは行う。パディングは次の手順で行う。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e末尾に 1-bit の 1 を付加する\u003c/li\u003e\n\u003cli\u003eメッセージ長が mod 512-bit = 448 になるまで 0 を末尾に付加する\u003c/li\u003e\n\u003cli\u003eオリジナルのメッセージ長を 64-bit で付加する\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e次の関数を定義する。\u003c/p\u003e\n\u003cpre\u003e\n\u003ccode\u003ef(t; B, C, D) = (B \u0026 C) | ((~B) \u0026 D); (0 \u003c= t \u003c= 19)\u003c/code\u003e\n\u003ccode\u003ef(t; B, C, D) = B ^ C ^ D; (20 \u003c= t \u003c= 39)\u003c/code\u003e\n\u003ccode\u003ef(t; B, C, D) = (B \u0026 C) | (B \u0026 D) | (C \u0026 D) (40 \u003c= t \u003c= 59)\u003c/code\u003e\n\u003ccode\u003ef(t; B, C, D) = B ^ C ^ D; (60 \u003c= t \u003c= 79)\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003eK(t) = 0x5A827999; (0 \u003c= t \u003c= 19)\u003c/code\u003e\n\u003ccode\u003eK(t) = 0x6ED9EBA1; (20 \u003c= t \u003c= 39)\u003c/code\u003e\n\u003ccode\u003eK(t) = 0x8F1BBCDC; (40 \u003c= t \u003c= 59)\u003c/code\u003e\n\u003ccode\u003eK(t) = 0xCA62C1D6; (60 \u003c= t \u003c= 79)\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003eS^N(n) = (M \u003c\u003c n) | (M \u003e\u003e (32 - n)) // 循環左シフト\u003c/code\u003e\n\u003ccode\u003eA + B = (A + B) mod (2 ** 32)\u003c/code\u003e\n\u003c/pre\u003e\u003cp\u003e複数の計算方法があるようだが、今回は次の方法で計算した。\u003c/p\u003e\n\u003cpre\u003e\n\u003ccode\u003eM: 512-bit ごとに区切ったメッセージ\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003eH0 = 0x67452301\u003c/code\u003e\n\u003ccode\u003eH1 = 0xEFCDAB89\u003c/code\u003e\n\u003ccode\u003eH2 = 0x98BADCFE\u003c/code\u003e\n\u003ccode\u003eH3 = 0x10325476\u003c/code\u003e\n\u003ccode\u003eH4 = 0xC3D2E1F0\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003efor each M(i)\u003c/code\u003e\n\u003ccode\u003e    W[16] = M(i) // M(i) を 32-bit ごとに分割する\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003e    for t from 16 to 79\u003c/code\u003e\n\u003ccode\u003e        W[t] = S^1(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16])\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003e    A = H0; B = H1; C = H2; D = H3; E = H4\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003e    for t from 0 to 79\u003c/code\u003e\n\u003ccode\u003e        TMP = S^5(A) + f(t; B, C, D) + E + W[t] + K(t)\u003c/code\u003e\n\u003ccode\u003e        E = D; D = C; C = s^30(B); A = TMP\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003e    H0 += A; H1 += B; H2 += C; H3 += D; H4 += E\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003e// H0 H1 H2 H3 H4 をこの順で並べる\u003c/code\u003e\n\u003c/pre\u003e\u003ch2\u003e実装で苦しんだところ (大体うっかり)\u003c/h2\u003e\n\u003ch3\u003eHOTP\u003c/h3\u003e\n\u003cp\u003eC は 8-byte 整数。\u003c/p\u003e\n\u003ch3\u003eHMAC\u003c/h3\u003e\n\u003cp\u003eハッシュ関数に SHA-1 を使用する場合、ブロック長は 64-byte、出力長は 20-byte であることから、K にハッシュを通した後に 0 を追加する処理を行う必要がある。\u003c/p\u003e\n\u003ch3\u003eSHA-1\u003c/h3\u003e\n\u003cp\u003e(追記あり) 左循環シフト。\u003ccode\u003e(n: number, x: number) =\u0026gt; (x \u0026lt;\u0026lt; n) | (x \u0026gt;\u0026gt; (32 - n))\u003c/code\u003e と素直に書くと、x は 32-bit 整数、\u003ccode\u003e0 \u0026lt;= n \u0026lt; 32\u003c/code\u003e であることからオーバーフローする。\u003c/p\u003e\n\u003ch2\u003e参考にしたもの\u003c/h2\u003e\n\u003cdl\u003e\n    \u003cdt\u003eIPA の RFC 日本語訳\u003c/dt\u003e\n    \u003cdd\u003eHMAC と SHA-1 の実装\u003c/dd\u003e\n    \u003cdt\u003eGolang のソースコード\u003c/dt\u003e\n    \u003cdd\u003eテストケースや各アルゴリズムの実装。読みやすい。\u003c/dd\u003e\n    \u003cdt\u003eRFC\u003c/dt\u003e\n    \u003cdd\u003eテスト用のサンプルケースが Appendix に書いてあることを初めて知った\u003c/dd\u003e\n\u003c/dl\u003e\n\n\n\u003ch2\u003e左循環シフトの高速化\u003c/h2\u003e\n\u003cp\u003e\u003ca href=https://github.com/comame/TOTP/compare/e495732d9156e805c78ff2626e95f09301123b32...361549fc64a207bcc402f48f802ee4d68b61cac6 target='_blank' rel='noopener'\u003ehttps://github.com/comame/TOTP/compare/e495732d9156e805c78ff2626e95f09301123b32...361549fc64a207bcc402f48f802ee4d68b61cac6\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003eオーバーフローをしないためにビットの配列に変換してシフト操作をしていたものを、number のまま計算できるように書き換えた。オーバーフローを起こさないため、32-bit 整数を 8-bit ずつに区切り、場合分けした。また、シフト演算子を使うとオーバーフローを起こすため、掛け算と割り算でシフト演算子と同等の計算を行うようにした。\u003c/p\u003e\n\u003cp\u003e次のようなコードで 10 回ずつ計測しそれぞれ平均をとったところ、高速化前は 616 ms、高速化後は 5 ms となった。\u003c/p\u003e\n\u003cp\u003eまた、SHA-1 の計算自体も、おおむね半分から 5 分の 1 程度の実行時間に短縮された。\u003c/p\u003e\n\u003cpre\u003e\n\u003ccode\u003econst t = Date.now()\u003c/code\u003e\n\u003ccode\u003efor (let i = 0; i \u003c 100000; i +=1) circularShift(16, 0x12345678)\u003c/code\u003e\n\u003ccode\u003econsole.log(Date.now() - t)\u003c/code\u003e\n\u003c/pre\u003e\u003cpre\u003e\n\u003ccode\u003e測定結果\u003c/code\u003e\n\u003ccode\u003e\u003c/code\u003e\n\u003ccode\u003e高速化前 [ms]\u003c/code\u003e\n\u003ccode\u003e    608 605 611 598 612 599 698 605 612 611\u003c/code\u003e\n\u003ccode\u003e高速化後 [ms]\u003c/code\u003e\n\u003ccode\u003e    4   4   6   4   5   5   5   4   5   5\u003c/code\u003e\n\u003c/pre\u003e"},"__N_SSG":true},"page":"/entries/[date]/[id]","query":{"date":"2020-07-20","id":"implement-totp-in-js"},"buildId":"eaJIyxMmkhvvLZTiksMV8","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-e750b8bf0c81a657f011.js"></script><script src="/_next/static/chunks/main-f01cf1dcca173d7f43b1.js" async=""></script><script src="/_next/static/chunks/webpack-ccf5ab034a524403276a.js" async=""></script><script src="/_next/static/chunks/framework.ea5d6f7a7099b14097ba.js" async=""></script><script src="/_next/static/chunks/commons.136473f176143783e714.js" async=""></script><script src="/_next/static/chunks/pages/_app-7826aa35c5692e1bca69.js" async=""></script><script src="/_next/static/chunks/44192d0b83adb4471c56c08528820b1f17270e33.228b4631e982fe3bd0c5.js" async=""></script><script src="/_next/static/chunks/pages/entries/%5Bdate%5D/%5Bid%5D-217160f5fe64bb279c4b.js" async=""></script><script src="/_next/static/eaJIyxMmkhvvLZTiksMV8/_buildManifest.js" async=""></script><script src="/_next/static/eaJIyxMmkhvvLZTiksMV8/_ssgManifest.js" async=""></script></body></html>