<!DOCTYPE html><html lang="ja"><head><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>ブログシステムを新しくした (技術面) | blog.comame.xyz</title><meta property="og:type" content="article"/><meta property="og:url" content="https://blog.comame.xyz/entries/2020-03-11/blog-tech.md"/><meta property="og:title" content="ブログシステムを新しくした (技術面) | blog.comame.xyz"/><meta property="og:site_name" content="blog.comame.xyz"/><meta property="og:description" content=""/><meta name="description" content=""/><meta name="next-head-count" content="9"/><link rel="preload" href="/_next/static/css/75b3a985ae8df8a5857d.css" as="style"/><link rel="stylesheet" href="/_next/static/css/75b3a985ae8df8a5857d.css"/><link rel="preload" href="/_next/static/css/7e552a05a23ef38b9280.css" as="style"/><link rel="stylesheet" href="/_next/static/css/7e552a05a23ef38b9280.css"/><link rel="preload" href="/_next/static/chunks/main-f01cf1dcca173d7f43b1.js" as="script"/><link rel="preload" href="/_next/static/chunks/webpack-ccf5ab034a524403276a.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.ea5d6f7a7099b14097ba.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.136473f176143783e714.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-7826aa35c5692e1bca69.js" as="script"/><link rel="preload" href="/_next/static/chunks/44192d0b83adb4471c56c08528820b1f17270e33.228b4631e982fe3bd0c5.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/entries/%5Bdate%5D/%5Bid%5D-217160f5fe64bb279c4b.js" as="script"/></head><body><div id="__next"><header class="header_header__10AWY"><a href="/">blog.comame.xyz</a></header><div class="post"><div class="metadata_metadata__3aUvp"><h1 id="title">ブログシステムを新しくした (技術面)</h1><time id="time">2020-03-11</time><ul class="tag-list_tag-list__1Wf57"><li><a href="/tags/Blog.html">Blog</a></li></ul></div><div class="content_content__3lhGG"><p>このブログの技術的な要素を解説する。最終的に静的なファイルとして出力されるまでの流れは、概ね次のようになる。</p>
<ol>
<li>ブラウザ上の JavaScript で記事データを読み、ページを生成する</li>
<li>Puppeteer でスクリプト実行後のページを保存する</li>
<li>記事データを読み、サイトマップやフィードを書き出す</li>
</ol>
<p>理念として、ビルドをする前でも完全なページが閲覧できるようにすることを目指した。</p>
<h2>記事データ</h2>
<ul>
<li><a href=https://github.com/comame/blog.comame.xyz/blob/master/archives/entries.json target='_blank' rel='noopener'>archives/entries.json</a></li>
</ul>
<p>年毎にディレクトリを分けることにした。</p>
<h3><code>archives/entries.json</code></h3>
<p>すべての記事のメタデータを保存する。ページを生成するときに参照する。</p>
<ul>
<li><code>entry</code>: <code>.html</code> 拡張子を付けるとファイル名と対応する。</li>
<li><code>title</code>: ページに表示されるタイトル。</li>
<li><code>date</code>: <code>yyyy-mm-dd</code> の形式。</li>
<li><code>tags</code>: 文字列の配列。</li>
</ul>
<h2>フロントエンドでのページ生成</h2>
<ul>
<li><a href=https://github.com/comame/blog.comame.xyz/blob/master/index.html target='_blank' rel='noopener'>index.html</a></li>
<li><a href=https://github.com/comame/blog.comame.xyz/blob/master/assets/js/app.js target='_blank' rel='noopener'>assets/js/app.js</a></li>
</ul>
<p>記事データを読み込んで、ページを生成する。後に Puppeteer でスクレイピングする際にページが生成し終わったことを確認できるよう、ページの生成後に特別な <code>&lt;meta&gt;</code> タグを埋め込んだ。</p>
<p>今回は自前のルーターライブラリを用いたが、React などを使っても問題ないはず。</p>
<h3>記事の一覧・タグ</h3>
<p><code>entries.json</code> を Fetch API で取得し、該当するページの情報を得た。</p>
<h3>記事ページ</h3>
<p><code>entries.json</code> から記事の HTML のファイルパスを取得し、HTML を埋め込んだ。</p>
<h2>Node.js を使ったビルド</h2>
<ul>
<li><a href=https://github.com/comame/blog.comame.xyz/blob/master/build.js target='_blank' rel='noopener'>build.js</a></li>
<li><a href=https://github.com/comame/blog.comame.xyz/blob/master/build/comameito_puppeteer-nginx target='_blank' rel='noopener'>build/comameito_puppeteer-nginx</a></li>
</ul>
<p>基本的には <code>main()</code> を追っていけばよい。Puppeteer が確実に動くようにするため、<a href=https://github.com/puppeteer/puppeteer/blob/master/docs/troubleshooting.md#chrome-headless-doesnt-launch-on-unix target='_blank' rel='noopener'>Puppeteer に必要な依存関係</a>, Nginx, Node.jsをインストールした Docker コンテナを事前に用意した。</p>
<h3><code>buildMarkdown()</code></h3>
<p><a href=https://www.npmjs.com/package/markdown-it target='_blank' rel='noopener'>markdown-it</a> を使って、Markdown で書かれた記事を HTML に変換する。</p>
<p>[追記] API がよりシンプルで、カスタマイズが簡単な <a href=https://www.npmjs.com/package/marked target='_blank' rel='noopener'>marked</a> を使うように変更した。それにより、外部リンクは新しいタブで開くようにした。</p>
<p>[追記] 静的ビルド前でも完全なページが表示できるよう、Markdowm のビルドをフロントエンドに移動した。</p>
<h3><code>copyAssets()</code></h3>
<p><code>assets/</code> を再帰的に潜っていって、画像や CSS、JavaScript などのファイルをそのままコピーする。</p>
<h3><code>crawl()</code></h3>
<p><a href=https://github.com/puppeteer/puppeteer target='_blank' rel='noopener'>Puppeteer</a> を用いて、実際に見えている Web ページを JavaScript を用いない静的な HTML ファイルに変換した。<code>index.html</code> から内部リンクをすべて拾っていく形にしている。Puppeteer では Browser Context でのスクリプトも簡単に実行できるため、あまり苦労しなかった。</p>
<p><code>load</code> イベントと JavaScipt の実行が完了するタイミングが一致しない (非同期処理) ため、スクリプトでのページ生成が終わった時点で追加される <code>meta</code> タグを待機してからページを保存する (<a href=https://github.com/puppeteer/puppeteer/blob/v2.1.1/docs/api.md#pagewaitforselectorselector-options target='_blank' rel='noopener'><code>async page.waitForSelector(selector)</code></a> が便利だった)。</p>
<p>無限ループを防ぐために、保存済みページの URL の Set を受け取るようにした。これは後のサイトマップ生成でも活用されることになった。</p>
<p>読み込みの高速化のため、ページ生成用の JavaScript を削除し、CSS をインラインに展開している。</p>
<h3><code>createSitemap()</code></h3>
<p><code>crawl()</code> で作成した保存済みページの URL のセットから、サイトマップを書き出した。今回は URL を列挙しただけのテキストファイルにした。</p>
<h3><code>createFeed()</code></h3>
<p><code>entries.json</code> から、Atom のフィードを生成する。</p>
<p>[追記] Markdown のビルドが移動した影響で、Puppeteer を使って記事の内容を拾うようにした。</p>
<h2>GitHub Actions</h2>
<ul>
<li><a href=https://github.com/comame/blog.comame.xyz/blob/master/.github/workflows/build.yml target='_blank' rel='noopener'>.github/workflows/build.yml</a></li>
</ul>
<p>Node.js のビルドは、GitHub Actions で自動的に行うことにした。ビルド用の Docker コンテナを起動し、Node.js でビルドし、生成物を commit するようになっている。</p>
<h2>公開</h2>
<p>GitHub Pages を使うようにした。GitHub Actions でのビルドが終わり、レポジトリに push されると自動的に反映される。</p>
</div><div class="share_share__2h1cH"><img alt="共有" src="/icons/share.svg"/><a rel="noopener" target="_blank" title="Twitter で共有" href="https://twitter.com/intent/tweet?text=%E3%83%96%E3%83%AD%E3%82%B0%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%82%92%E6%96%B0%E3%81%97%E3%81%8F%E3%81%97%E3%81%9F%20(%E6%8A%80%E8%A1%93%E9%9D%A2)%0a&amp;url=https%3A%2F%2Fblog.comame.xyz%2Fentries%2F2020-03-11%2Fblog-tech.md&amp;related=comameito"><img alt="Twitter で共有" src="/icons/twitter_logo.svg"/></a><a rel="noopener" target="_blank" title="Facebook で共有" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fblog.comame.xyz%2Fentries%2F2020-03-11%2Fblog-tech.md"><img alt="Facebook で共有" src="/icons/facebook_logo.svg"/></a><a title="URL をコピー" id="url-copy"><img alt="URL をコピー" src="/icons/link.svg"/></a><script async="" src="/js/url-copy.js"></script></div></div><footer class="footer_footer__cDy4s"><small><a href="https://github.com/comame/blog.comame.xyz" target="_blank" rel="noopener"><img alt="GitHub Actions build status" id="build-status" src="https://github.com/comame/blog.comame.xyz/workflows/Build/badge.svg?event=push"/></a></small><small><span>Copyright 2020 <a href="https://comame.xyz">comame</a></span><span><a target="_blank" rel="noopener" href="https://github.com/comame/blog.comame.xyz/blob/master/archives/2020/blog-tech.md">source</a></span><span><a target="_blank" rel="noopener" href="https://github.com/comame/blog.comame.xyz/commits/master/archives/2020/blog-tech.md">history</a></span><span><a href="/feed.xml">Feed</a></span></small></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"entry":{"entry":"blog-tech","title":"ブログシステムを新しくした (技術面)","date":"2020-03-11","tags":["Blog"],"type":"md"},"text":"\u003cp\u003eこのブログの技術的な要素を解説する。最終的に静的なファイルとして出力されるまでの流れは、概ね次のようになる。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eブラウザ上の JavaScript で記事データを読み、ページを生成する\u003c/li\u003e\n\u003cli\u003ePuppeteer でスクリプト実行後のページを保存する\u003c/li\u003e\n\u003cli\u003e記事データを読み、サイトマップやフィードを書き出す\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e理念として、ビルドをする前でも完全なページが閲覧できるようにすることを目指した。\u003c/p\u003e\n\u003ch2\u003e記事データ\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=https://github.com/comame/blog.comame.xyz/blob/master/archives/entries.json target='_blank' rel='noopener'\u003earchives/entries.json\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e年毎にディレクトリを分けることにした。\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003earchives/entries.json\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003eすべての記事のメタデータを保存する。ページを生成するときに参照する。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eentry\u003c/code\u003e: \u003ccode\u003e.html\u003c/code\u003e 拡張子を付けるとファイル名と対応する。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etitle\u003c/code\u003e: ページに表示されるタイトル。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003edate\u003c/code\u003e: \u003ccode\u003eyyyy-mm-dd\u003c/code\u003e の形式。\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003etags\u003c/code\u003e: 文字列の配列。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003eフロントエンドでのページ生成\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=https://github.com/comame/blog.comame.xyz/blob/master/index.html target='_blank' rel='noopener'\u003eindex.html\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=https://github.com/comame/blog.comame.xyz/blob/master/assets/js/app.js target='_blank' rel='noopener'\u003eassets/js/app.js\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e記事データを読み込んで、ページを生成する。後に Puppeteer でスクレイピングする際にページが生成し終わったことを確認できるよう、ページの生成後に特別な \u003ccode\u003e\u0026lt;meta\u0026gt;\u003c/code\u003e タグを埋め込んだ。\u003c/p\u003e\n\u003cp\u003e今回は自前のルーターライブラリを用いたが、React などを使っても問題ないはず。\u003c/p\u003e\n\u003ch3\u003e記事の一覧・タグ\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eentries.json\u003c/code\u003e を Fetch API で取得し、該当するページの情報を得た。\u003c/p\u003e\n\u003ch3\u003e記事ページ\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eentries.json\u003c/code\u003e から記事の HTML のファイルパスを取得し、HTML を埋め込んだ。\u003c/p\u003e\n\u003ch2\u003eNode.js を使ったビルド\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=https://github.com/comame/blog.comame.xyz/blob/master/build.js target='_blank' rel='noopener'\u003ebuild.js\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=https://github.com/comame/blog.comame.xyz/blob/master/build/comameito_puppeteer-nginx target='_blank' rel='noopener'\u003ebuild/comameito_puppeteer-nginx\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e基本的には \u003ccode\u003emain()\u003c/code\u003e を追っていけばよい。Puppeteer が確実に動くようにするため、\u003ca href=https://github.com/puppeteer/puppeteer/blob/master/docs/troubleshooting.md#chrome-headless-doesnt-launch-on-unix target='_blank' rel='noopener'\u003ePuppeteer に必要な依存関係\u003c/a\u003e, Nginx, Node.jsをインストールした Docker コンテナを事前に用意した。\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ebuildMarkdown()\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ca href=https://www.npmjs.com/package/markdown-it target='_blank' rel='noopener'\u003emarkdown-it\u003c/a\u003e を使って、Markdown で書かれた記事を HTML に変換する。\u003c/p\u003e\n\u003cp\u003e[追記] API がよりシンプルで、カスタマイズが簡単な \u003ca href=https://www.npmjs.com/package/marked target='_blank' rel='noopener'\u003emarked\u003c/a\u003e を使うように変更した。それにより、外部リンクは新しいタブで開くようにした。\u003c/p\u003e\n\u003cp\u003e[追記] 静的ビルド前でも完全なページが表示できるよう、Markdowm のビルドをフロントエンドに移動した。\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ecopyAssets()\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eassets/\u003c/code\u003e を再帰的に潜っていって、画像や CSS、JavaScript などのファイルをそのままコピーする。\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ecrawl()\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ca href=https://github.com/puppeteer/puppeteer target='_blank' rel='noopener'\u003ePuppeteer\u003c/a\u003e を用いて、実際に見えている Web ページを JavaScript を用いない静的な HTML ファイルに変換した。\u003ccode\u003eindex.html\u003c/code\u003e から内部リンクをすべて拾っていく形にしている。Puppeteer では Browser Context でのスクリプトも簡単に実行できるため、あまり苦労しなかった。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eload\u003c/code\u003e イベントと JavaScipt の実行が完了するタイミングが一致しない (非同期処理) ため、スクリプトでのページ生成が終わった時点で追加される \u003ccode\u003emeta\u003c/code\u003e タグを待機してからページを保存する (\u003ca href=https://github.com/puppeteer/puppeteer/blob/v2.1.1/docs/api.md#pagewaitforselectorselector-options target='_blank' rel='noopener'\u003e\u003ccode\u003easync page.waitForSelector(selector)\u003c/code\u003e\u003c/a\u003e が便利だった)。\u003c/p\u003e\n\u003cp\u003e無限ループを防ぐために、保存済みページの URL の Set を受け取るようにした。これは後のサイトマップ生成でも活用されることになった。\u003c/p\u003e\n\u003cp\u003e読み込みの高速化のため、ページ生成用の JavaScript を削除し、CSS をインラインに展開している。\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ecreateSitemap()\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ecrawl()\u003c/code\u003e で作成した保存済みページの URL のセットから、サイトマップを書き出した。今回は URL を列挙しただけのテキストファイルにした。\u003c/p\u003e\n\u003ch3\u003e\u003ccode\u003ecreateFeed()\u003c/code\u003e\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eentries.json\u003c/code\u003e から、Atom のフィードを生成する。\u003c/p\u003e\n\u003cp\u003e[追記] Markdown のビルドが移動した影響で、Puppeteer を使って記事の内容を拾うようにした。\u003c/p\u003e\n\u003ch2\u003eGitHub Actions\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=https://github.com/comame/blog.comame.xyz/blob/master/.github/workflows/build.yml target='_blank' rel='noopener'\u003e.github/workflows/build.yml\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eNode.js のビルドは、GitHub Actions で自動的に行うことにした。ビルド用の Docker コンテナを起動し、Node.js でビルドし、生成物を commit するようになっている。\u003c/p\u003e\n\u003ch2\u003e公開\u003c/h2\u003e\n\u003cp\u003eGitHub Pages を使うようにした。GitHub Actions でのビルドが終わり、レポジトリに push されると自動的に反映される。\u003c/p\u003e\n"},"__N_SSG":true},"page":"/entries/[date]/[id]","query":{"date":"2020-03-11","id":"blog-tech"},"buildId":"eaJIyxMmkhvvLZTiksMV8","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-e750b8bf0c81a657f011.js"></script><script src="/_next/static/chunks/main-f01cf1dcca173d7f43b1.js" async=""></script><script src="/_next/static/chunks/webpack-ccf5ab034a524403276a.js" async=""></script><script src="/_next/static/chunks/framework.ea5d6f7a7099b14097ba.js" async=""></script><script src="/_next/static/chunks/commons.136473f176143783e714.js" async=""></script><script src="/_next/static/chunks/pages/_app-7826aa35c5692e1bca69.js" async=""></script><script src="/_next/static/chunks/44192d0b83adb4471c56c08528820b1f17270e33.228b4631e982fe3bd0c5.js" async=""></script><script src="/_next/static/chunks/pages/entries/%5Bdate%5D/%5Bid%5D-217160f5fe64bb279c4b.js" async=""></script><script src="/_next/static/eaJIyxMmkhvvLZTiksMV8/_buildManifest.js" async=""></script><script src="/_next/static/eaJIyxMmkhvvLZTiksMV8/_ssgManifest.js" async=""></script></body></html>