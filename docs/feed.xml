<?xml version='1.0'?>
    <feed xmlns='http://www.w3.org/2005/Atom'>
      <id>https://blog.comame.xyz/</id>
      <title>blog.comame.xyz</title>
      <link rel='alternate' href='https://blog.comame.xyz/' />
      <link rel='self' href='https://blog.comame.xyz/feed.xml' />
      <author><name>comame</name></author>
      <updated>2020-03-11T00:00:00Z</updated>

      
    <entry>
      <title>ブログシステムを新しくした (技術面)</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2020-03-11/blog-tech' />
      <id>https://blog.comame.xyz/entries/2020-03-11/blog-tech</id>
      <updated>2020-03-11T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;このブログの技術的な要素を解説する。最終的に静的なファイルとして出力されるまでの流れは、概ね次のようになる。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ブラウザ上の JavaScript で記事データを読み、ページを生成する&lt;/li&gt;
&lt;li&gt;Puppeteer でスクリプト実行後のページを保存する&lt;/li&gt;
&lt;li&gt;記事データを読み、サイトマップやフィードを書き出す&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;記事データ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=https://github.com/comame/blog.comame.xyz/blob/master/archives/entries.json target='_blank'&gt;archives/entries.json&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;年毎にディレクトリを分けることにした。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;archives/entries.json&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;すべての記事のメタデータを保存する。ページを生成するときに参照する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;entry&lt;/code&gt;: &lt;code&gt;.html&lt;/code&gt; 拡張子を付けるとファイル名と対応する。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;title&lt;/code&gt;: ページに表示されるタイトル。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;date&lt;/code&gt;: &lt;code&gt;yyyy-mm-dd&lt;/code&gt; の形式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tags&lt;/code&gt;: 文字列の配列。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;フロントエンドでのページ生成&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=https://github.com/comame/blog.comame.xyz/blob/master/index.html target='_blank'&gt;index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=https://github.com/comame/blog.comame.xyz/blob/master/assets/js/app.js target='_blank'&gt;assets/js/app.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;記事データを読み込んで、ページを生成する。後に Puppeteer でスクレイピングする際にページが生成し終わったことを確認できるよう、ページの生成後に特別な &lt;code&gt;&lt;meta&gt;&lt;/code&gt; タグを埋め込んだ。&lt;/p&gt;
&lt;p&gt;今回は自前のルーターライブラリを用いたが、React などを使っても問題ないはず。&lt;/p&gt;
&lt;h3&gt;記事の一覧・タグ&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;entries.json&lt;/code&gt; を Fetch API で取得し、該当するページの情報を得た。&lt;/p&gt;
&lt;h3&gt;記事ページ&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;entries.json&lt;/code&gt; から記事の HTML のファイルパスを取得し、HTML を埋め込んだ。&lt;/p&gt;
&lt;h2&gt;Node.js を使ったビルド&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=https://github.com/comame/blog.comame.xyz/blob/master/build.js target='_blank'&gt;build.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=https://github.com/comame/blog.comame.xyz/blob/master/build/comameito_puppeteer-nginx target='_blank'&gt;build/comameito_puppeteer-nginx&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本的には &lt;code&gt;main()&lt;/code&gt; を追っていけばよい。Puppeteer が確実に動くようにするため、&lt;a href=https://github.com/puppeteer/puppeteer/blob/master/docs/troubleshooting.md target='_blank'&gt;Puppeteer に必要な依存関係&lt;/a&gt;, Nginx, Node.jsをインストールした Docker コンテナを事前に用意した。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;buildMarkdown()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=https://www.npmjs.com/package/markdown-it target='_blank'&gt;markdown-it&lt;/a&gt; を使って、Markdown で書かれた記事を HTML に変換する。&lt;/p&gt;
&lt;p&gt;[追記] API がよりシンプルで、カスタマイズが簡単な &lt;a href=https://www.npmjs.com/package/marked target='_blank'&gt;marked&lt;/a&gt; を使うように変更した。それにより、外部リンクは新しいタブで開くようにした。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;copyAssets()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;assets/&lt;/code&gt; を再帰的に潜っていって、画像や CSS、JavaScript などのファイルをそのままコピーする。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;crawl()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href=https://github.com/puppeteer/puppeteer target='_blank'&gt;Puppeteer&lt;/a&gt; を用いて、実際に見えている Web ページを JavaScript を用いない静的な HTML ファイルに変換した。&lt;code&gt;index.html&lt;/code&gt; から内部リンクをすべて拾っていく形にしている。Puppeteer では Browser Context でのスクリプトも簡単に実行できるため、あまり苦労しなかった。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;load&lt;/code&gt; イベントと JavaScipt の実行が完了するタイミングが一致しない (非同期処理) ため、スクリプトでのページ生成が終わった時点で追加される &lt;code&gt;meta&lt;/code&gt; タグを待機してからページを保存する (&lt;a href=https://github.com/puppeteer/puppeteer/blob/v2.1.1/docs/api.md#pagewaitforselectorselector-options target='_blank'&gt;&lt;code&gt;async page.waitForSelector(selector)&lt;/code&gt;&lt;/a&gt; が便利だった)。&lt;/p&gt;
&lt;p&gt;無限ループを防ぐために、保存済みページの URL の Set を受け取るようにした。これは後のサイトマップ生成でも活用されることになった。&lt;/p&gt;
&lt;p&gt;読み込みの高速化のため、ページ生成用の JavaScript を削除し、CSS をインラインに展開している。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;createSitemap()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;crawl()&lt;/code&gt; で作成した保存済みページの URL のセットから、サイトマップを書き出した。今回は URL を列挙しただけのテキストファイルにした。&lt;/p&gt;
&lt;h3&gt;&lt;code&gt;createFeed()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;entries.json&lt;/code&gt; から、Atom のフィードを生成する。&lt;/p&gt;
&lt;h2&gt;GitHub Actions&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=https://github.com/comame/blog.comame.xyz/blob/master/.github/workflows/build.yml target='_blank'&gt;.github/workflows/build.yml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Node.js のビルドは、GitHub Actions で自動的に行うことにした。ビルド用の Docker コンテナを起動し、Node.js でビルドし、生成物を commit するようになっている。&lt;/p&gt;
&lt;h2&gt;公開&lt;/h2&gt;
&lt;p&gt;GitHub Pages を使うようにした。GitHub Actions でのビルドが終わり、レポジトリに push されると自動的に反映される。&lt;/p&gt;
</content>
    </entry>
    
    <entry>
      <title>WSL2 で Docker を自動起動する</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2020-03-08/docker-startup-wsl2' />
      <id>https://blog.comame.xyz/entries/2020-03-08/docker-startup-wsl2</id>
      <updated>2020-03-08T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;WSL2 では systemctl が使えないため、システムの起動時に Docker を自動起動することができない。ただ、Windows 側のタスクスケジューラを使えばできるらしい。&lt;/p&gt;

&lt;h2&gt;方法&lt;/h2&gt;
&lt;h3&gt;起動用スクリプトを書く&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#!/usr/bin/env bash
# このファイルに実行権限も付与しておく
sudo service docker start&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;パスワードなしで実行できるようにする&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#/etc/sudoers
user ALL=(ALL:ALL) NOPASSWD: /bin/sh /path/to/script
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;タスクスケジューラに設定する&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;全般「最上位の特権で実行する」&lt;/li&gt;
    &lt;li&gt;トリガー「ログイン時」&lt;/li&gt;
    &lt;li&gt;操作「C:\Windows\System32\bash.exe」「-c "sudo /bin/sh /path/to/script"」&lt;/li&gt;
    &lt;li&gt;条件「AC電源に接続されているときのみ」を外す&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;参考&lt;/h3&gt;
&lt;p&gt;こちらの Qiita 記事を参考にした。&lt;a href="https://qiita.com/Ningensei848/items/75adeb29bb143633d60c" target="_blank"&gt;Automatically Docker Daemon Boot on Windows Subsystem Linux（WSLにおけるdockerデーモンの自動起動）&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    <entry>
      <title>ブログシステムを新しくした (Blogger からの移行)</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2020-03-07/new-blog-system' />
      <id>https://blog.comame.xyz/entries/2020-03-07/new-blog-system</id>
      <updated>2020-03-07T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;新しいブログシステムを作成して、Blogger から移行した。今は静的ファイルとして静的ファイルサーバから配信している。GitHub でソースコードを公開した。&lt;a href="https://github.com/comame/blog.comame.xyz" target="_blank"&gt;comame/blog.comame.xyz&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;モチベーション&lt;/h2&gt;
&lt;ul&gt;
    &lt;li&gt;自分が制御可能な形でデータを置きたかった&lt;/li&gt;
    &lt;li&gt;自分の慣れているエディタで HTML を書きたかった&lt;/li&gt;
    &lt;li&gt;Blogger は読み込み速度が少し遅かった&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;仕組み&lt;/h2&gt;

&lt;h3&gt;記事の管理&lt;/h3&gt;
&lt;p&gt;&lt;a target='_blank' href="https://github.com/comame/blog.comame.xyz/tree/master/archives"&gt;archives/&lt;/a&gt; 配下にすべての記事データを置いている。タイトルやタグ、日付などのメタデータは archives/entries.json に記載する。&lt;/p&gt;

&lt;h3&gt;ページの生成&lt;/h3&gt;
&lt;p&gt;JavaScript で archives/entries.json を読み、記事データを展開している。これらは &lt;a target='_blank' href="https://github.com/comame/blog.comame.xyz/blob/master/assets/js/app.js"&gt;assets/js/app.js&lt;/a&gt; で処理している。History API を使って動的に URL を書き換えているため、Apache や Nginx で URL のリライトが必要。&lt;/p&gt;

&lt;h3&gt;静的ビルド&lt;/h3&gt;
&lt;p&gt;ユーザーが閲覧する環境で毎回スクリプトでページを生成するのは筋が悪いため、手元で静的ファイルとしてビルドを行う。ページは JavaScript を使って生成するため、Puppeteer でクロールしてスクリプト実行後の HTML を静的ファイルとして保存している。画像ファイルなどのアセットは、/assets に置いておけば /build/assets にそのままコピーされる。ビルド用のスクリプトは &lt;a target='_blank' href="https://github.com/comame/blog.comame.xyz/blob/master/build.js"&gt;build.js&lt;/a&gt; である。&lt;/p&gt;

&lt;h2&gt;今後の運用&lt;/h2&gt;
&lt;p&gt;VSCode で記事を書き、手元でビルドし、GitHub にアップする。あとはビルド済みの静的ファイルを適当に配信すればよい。今回は GitHub Pages で公開することにした。自分の開発環境で記事をかけるため、かなり書きやすくなった。一方で、ビルドをするためだけにローカルサーバを立てなければいけないのは結構面倒くさい。&lt;/p&gt;
&lt;p&gt;[追記] Git の post-commit フックを使って、自動的にビルドを走らせるようにしてみた。本当は GitHub Actions を使いたかったが、ビルド用のサーバを立てて、Puppeteer を起動して...とするのは厄介そうだったので妥協策ではある。post-commit フックは &lt;a href="https://github.com/comame/blog.comame.xyz/blob/194b480ee2beec8a75c7638ab7453078faa7aa3f/post-commit" target="_blank"&gt;post-commit&lt;/a&gt; に置いておく。&lt;/p&gt;
&lt;p&gt;[追記] &lt;a href="https://github.com/comame/blog.comame.xyz/tree/master/.github/workflows/build.yml" target="_blank"&gt;GitHub Actions&lt;/a&gt; で push したときにビルドが走るようにした。&lt;/p&gt;

&lt;h2&gt;今後やりたいこと&lt;/h2&gt;
&lt;ul&gt;
    &lt;li&gt;Markdown で記事を書けるようにする&lt;/li&gt;
    &lt;li&gt;WebP などの画像フォーマットに自動的に変換できるようにする&lt;/li&gt;
    &lt;li&gt;OGP に対応&lt;/li&gt;
    &lt;li&gt;[DONE] RSS フィードを生成できるようにする&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    <entry>
      <title>Windows 10 の ssh で Permission refusedが出る問題</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2020-02-19/windows-ssh-error' />
      <id>https://blog.comame.xyz/entries/2020-02-19/windows-ssh-error</id>
      <updated>2020-02-19T00:00:00Z</updated>
      <content type='html'>&lt;h2&gt;対処法&lt;/h2&gt;
&lt;p&gt;ssh-agent を有効にして、ssh-add する。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Set-Service -Name ssh-agent -StartupType Manual
Start-Service ssh-agent

ssh-add ~/.ssh/id_rsa&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href='https://qiita.com/yuta0801/items/d65f1fc3115773861283'&gt;Win10でssh-addがError connecting to agent: No such file or directory - Qiita&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    <entry>
      <title>CNAME トラッキングについての議論</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2020-01-20/cname-tracking' />
      <id>https://blog.comame.xyz/entries/2020-01-20/cname-tracking</id>
      <updated>2020-01-20T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;先日&lt;a href="https://twitter.com/comameito/status/1218434263768428544"&gt;割と感情的に呟いたもの&lt;/a&gt;がそこそこ拡散されてしまって、「良くないものだ」という気持ちだけが広まってしまうのは本意ではないので、改めてきちんとした議論をしたいという思いでこの記事を書きます。
&lt;/p&gt;
&lt;h2&gt;前提となる立場&lt;/h2&gt;
&lt;ul&gt;
    &lt;li&gt;トラッキングをすること自体の是非は問わない&lt;/li&gt;
    &lt;li&gt;トラッキングの手法についての議論である&lt;/li&gt;
    &lt;li&gt;ユーザーがトラッキングを望まない場合、積極的な対処をせずとも有効な選択肢が与えられる状態が望ましい&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;CNAME トラッキングの方法・背景&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://support.ebis.ne.jp/all_articles/100_featuretype/200_systemsetting/29550/"&gt;アドエビスによる解説&lt;/a&gt;がわかりやすいです。最近の
    Third-party Cookie に対する制限の回避策となり得ます。&lt;/p&gt;
&lt;h2&gt;セキュリティの懸念事項&lt;/h2&gt;
&lt;h3&gt;不適切な設定をされた Cookie が、トラッキングサービスに送信されてしまう&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Set-Cookie&lt;/code&gt; ヘッダに &lt;code&gt;Domain&lt;/code&gt; ディレクティブを指定した場合、すべてのサブドメインに Cookie
    が送信されてしまいます。もし認証に用いる機密情報などをこの方法で設定した場合、CNAME レコードとして設定したトラッキングサービスにも Cookie が送信されてしまいます。&lt;a
        href="https://developer.mozilla.org/ja/docs/Web/HTTP/Headers/Set-Cookie#Directives"&gt;Set-Cookie - HTTP | MDN&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;プライバシーの懸念事項&lt;/h2&gt;
&lt;h3&gt;ユーザーに情報収集することについての選択肢が与えられない&lt;/h3&gt;
&lt;p&gt;Third-party Cookie を使用して情報を収集する場合、ユーザーが Third-party Cookie
    をブロックすればトラッキングを防ぐことができます。また、これによってトラッキング以外の要素に与える影響はあまり大きくありません (Third-party Cookie
    を認証に使うようなことがない限り...)。一方、First-party Cookie を用いてトラッキングをする場合、ユーザーができることは First-party Cookie を拒否することです。First-party
    Cookie は認証などの様々な用途に使われており、影響は大きくなると想定されます。&lt;/p&gt;
&lt;p&gt;First-party Cookie
    をブロックすることによる影響が大きいことを鑑みると、これはユーザーによる積極的な行動とみるべきです。私の提案としては、ユーザーの不便が行動による効果を上回る場合、積極的な行動と取るべきだと考えています。積極的な行動か否かの判断は極めて難しいものであり、今後議論が進むことを期待します。
&lt;/p&gt;
&lt;p&gt;次に、ブラウザの拡張機能によって事前に DNS をクエリし、トラッキングサービスへの CNAME レコードがあればアクセスをブロックするという手法が考えられます。この手法にはいくつかの問題があります。すべてのリクエストごとに DNS
    クエリを走らせるため、パフォーマンスに影響が出ることが想定されます。ブラウザが拡張機能に対して DNS クエリを行う機能を提供するかどうかに依存します。&lt;/p&gt;
&lt;h2&gt;CNAME トラッキングに対する考察・提案&lt;/h2&gt;
&lt;p&gt;現時点において、有効な選択肢をユーザーに与えることが難しいこと・セキュリティの問題があることを踏まえると、代替手段が存在しない場合にのみ CNAME トラッキングを導入するべきだと考えます。&lt;/p&gt;
&lt;h3&gt;トラッキングサービスの提供者に期待すること&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;の不適切な設定による機密情報の漏洩を防ぐため、導入者に対して必要十分な助言をすること&lt;/li&gt;
    &lt;li&gt;ユーザーの同意を得るためのプロンプトを表示させる等、ユーザーに選択肢を提示するよう導入者に指導すること&lt;/li&gt;
    &lt;li&gt;ユーザーの同意が得られるまでトラッキングを行わないようにする機能を提供すること&lt;/li&gt;
    &lt;li&gt;将来的に有効な代替手段が提案されたときは、CNAME トラッキングを停止すること&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;トラッキングの導入者に期待すること&lt;/h3&gt;
&lt;ul&gt;
    &lt;li&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;について正しい知識を得て、Cookie の漏洩が起こらないようにすること&lt;/li&gt;
    &lt;li&gt;トラッキングを有効にする前に、個別のユーザーに対して有効な同意を得ること&lt;/li&gt;
&lt;/ul&gt;
</content>
    </entry>
    
    <entry>
      <title>Blogger のテーマ作成について</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2019-12-10/blogger-theme' />
      <id>https://blog.comame.xyz/entries/2019-12-10/blogger-theme</id>
      <updated>2019-12-10T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;&lt;a href='https://adventar.org/calendars/4197'&gt;Google Blogger Advent Calendar 2019&lt;/a&gt; の 10 日目の記事です。&lt;/p&gt;

&lt;p&gt;Blogger には、標準でおしゃれなテーマがいくつか付属しています。また、検索エンジンで少し調べてみれば、有志が作成した素晴らしいテーマを簡単に見つけることができます。しかし、こうは思ったことはありませんか？「自分だけのテーマを作ってみたい」と。&lt;/p&gt;
&lt;p&gt;この記事では、Blogger のテーマを作成するためのチュートリアルと TIPS をお届けします。&lt;/p&gt;

&lt;h2&gt;前置き&lt;/h2&gt;
&lt;p&gt;HTML や CSS などの基本的な Web 技術が多少分かることを前提としています。また、SEO を目的としたテーマ作成について扱うわけではありません。&lt;/p&gt;

&lt;h2&gt;まずはじめに&lt;/h2&gt;
&lt;h3&gt;Blogger のテーマってどこで作るの？&lt;/h3&gt;
&lt;p&gt;&lt;a href='https://blogger.com'&gt;Blogger&lt;/a&gt; を開き、「テーマ」を開きます。「HTML を編集」のボタンをクリックすると、エディタが開きます。あとは自分の HTML を書いていくだけです。(このエディタは結構使いにくいので、手元で書いたものを貼り付ける方が良いかもしれません。テキストエディタは VSCode や Atom, Sublime Text などが有名です)&lt;/p&gt;

&lt;h3&gt;Blogger のテンプレートを記述する XML って何？&lt;/h3&gt;
&lt;p&gt;Blogger のテーマは HTML とは少し形式の異なる、XML という言語で記述します。大まかな違いとしては、HTML は多少誤った記述をしても寛大に解釈されます (例えば、閉じタグを忘れても自動的に閉じてくれます)。一方で、XML は文法に則った記述をしないと、エラーとなってしまいます。具体的な違いとしては、まず XML では閉じタグを省略できません。&lt;code&gt;&lt;img&gt;&lt;/code&gt;などの閉じタグが不要なタグでも、必ず記述しなければなりません。
&lt;pre&gt;&lt;code&gt;閉じタグを忘れるとエラーになる
ng -- &lt;h1&gt;&lt;h2&gt;Heading&lt;/h1&gt;

閉じタグを省略できない
ok -- &lt;img src='https://example.com/foo.png'&gt;&lt;/img&gt;
ok -- &lt;img src='https://example.com/foo.png'/&gt;
ng -- &lt;img src='https://example.com/foo.png'&gt;&lt;/code&gt;&lt;/pre&gt;

また、ファイルの先頭に決められた形式の記述をしなければなりません。Blogger の場合は次のようになります。
&lt;pre&gt;&lt;code&gt;&lt;?xml version="1.0" encoding="UTF-8" ?&gt;

&lt;!DOCTYPE html&gt;
&lt;html b:responsive='true' lang='ja' xmlns='http://www.w3.org/1999/xhtml' xmlns:b='http://www.google.com/2005/gml/b' xmlns:data='http://www.google.com/2005/gml/data' xmlns:expr='http://www.google.com/2005/gml/expr'&gt;

&lt;!-- Your cool things here --&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;h2&gt;テーマの構成&lt;/h2&gt;
&lt;p&gt;Blogger のテーマには、決められた構成が存在します。これは皆さんが Blogger 管理画面の「レイアウト」で見慣れているものとほぼ同じです。Blogger のテーマで使用されるレイアウトのパーツには、b:section, b:widget, b:includable (b:include) があります。&lt;/p&gt;

&lt;p&gt;Blogger のレイアウト構成は次のようになっています。&lt;img alt='Blogger のレイアウト構成図' src="https://1.bp.blogspot.com/-Xtu3MKf6JhI/Xek_htDkw3I/AAAAAAABIcc/M-Wig09D2c0Pn3QEGAf80aSy6I24fhfWQCLcBGAsYHQ/s1600/%25E7%2584%25A1%25E9%25A1%258C%25E3%2581%25AE%25E5%259B%25B3%25E5%25BD%25A2%25E6%258F%258F%25E7%2594%25BB.png" /&gt;&lt;/p&gt;

&lt;h3&gt;b:section&lt;/h3&gt;
&lt;p&gt;レイアウトの最上位に配置されます。日本語の管理画面では「セクション」と表示されていますね。セクションにはウィジェットだけを含むことができます。
&lt;code&gt;id&lt;/code&gt;属性は必須です。他の ID と重複しない一意な文字列を指定します。
&lt;pre&gt;&lt;code&gt;&lt;b:section id='foo'&gt;
  &lt;!-- widgets --&gt;
&lt;/b:section&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;h3&gt;b:widget&lt;/h3&gt;
&lt;p&gt;セクションの中に配置されます。管理画面では「ウィジェット」と表示されています。皆さんが Blogger をカスタマイズするときには、最も良く扱う部分ではないでしょうか。ウィジェットの特徴としては、 Blogger によって用意されているものだけを使用できるという点が挙げられます。また、ウィジェット内には後述する &lt;code&gt;b:includable&lt;/code&gt;のみを配置できます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;id&lt;/code&gt;と&lt;code&gt;type&lt;/code&gt;属性は必須です。&lt;code&gt;type&lt;/code&gt;属性には BlogArchive, Blog, Header, LinkList, NavBar, BlogProfile などを指定できます。これらは管理画面から追加できるウィジェットと同じです。また、&lt;code&gt;id&lt;/code&gt;属性は Type + 連番の形式にする必要があります。
&lt;pre&gt;&lt;code&gt;&lt;b:section id='foo'&gt;

  &lt;b:widget id='Blog1' type='Blog'&gt;
    &lt;-- includables --&gt;
  &lt;/b:widget&gt;

  &lt;b:widget id='LinkList1' type='LinkList'&gt;
    &lt;-- includables --&gt;
  &lt;/b:widget&gt;

&lt;/b:section&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;b:includable&lt;/h3&gt;
&lt;p&gt;ウィジェットの中で使用されるパーツです。includable という名前が表すように、他の場所で再利用可能です。セクションやウィジェットと異なり、この中では自由に要素を追加できます。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;id&lt;/code&gt;属性は必須です。また、各ウィジェット内には必ず&lt;code&gt;main&lt;/code&gt;を ID とした includable が必要です。&lt;code&gt;main&lt;/code&gt;以外を指定した includable は、&lt;code&gt;b:include&lt;/code&gt;で明示的に指定しない限り、表示されません。
&lt;pre&gt;&lt;code&gt;&lt;b:section id='foo'&gt;
  &lt;b:widget id='Blog1' type='Blog'&gt;

    &lt;b:includable id='main'&gt;
      &lt;p&gt;やっと他の要素を書き込める！&lt;/p&gt;
    &lt;/b:includable&gt;

    &lt;b:includable id='another-includable'&gt;
      &lt;p&gt;まだ表示されない&lt;/p&gt;
    &lt;/b:includable&gt;

  &lt;/b:widget&gt;
&lt;/b:section&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;h3&gt;b:include&lt;/h3&gt;
&lt;p&gt;includable を再利用します。&lt;code&gt;name&lt;/code&gt;属性を使用して include するものを指定します。

&lt;pre&gt;&lt;code&gt;&lt;b:section id='foo'&gt;
  &lt;b:widget id='Blog1' type='Blog'&gt;

    &lt;b:includable id='main'&gt;
      &lt;p&gt;やっと他の要素を書き込める！&lt;/p&gt;
      &lt;b:include name='another-includable'&gt;&lt;/b:includable&gt;
    &lt;/b:includable&gt;

    &lt;b:includable id='another-includable'&gt;
      &lt;p&gt;main の中に表示された！&lt;/p&gt;
    &lt;/b:includable&gt;

  &lt;/b:widget&gt;
&lt;/b:section&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;h2&gt;データタグ / 制御タグ&lt;/h2&gt;

&lt;p&gt;ここまでは、Blogger のレイアウトを構成するタグを説明しました。実際にブログとして機能させるには、ブログのデータを埋め込んでいく必要があります。そこで使用するのがウィジェットタグです。ウィジェットタグは大まかに分類してデータタグと制御タグに分けることができます。&lt;/p&gt;

&lt;p&gt;データタグは、ブログのデータを表現します。例えば、&lt;code&gt;&lt;data:blog.title/&gt;&lt;/code&gt;というタグは、ブログのタイトルに置き換えられます。使用可能なデータタグは&lt;a href='https://support.google.com/blogger/answer/47270'&gt;ヘルプページ&lt;/a&gt;に説明がありますが、いくつか補足があります。「グローバルに利用可能なデータ」は、テーマ内の任意の場所で使用可能です。セクションの外であっても、例えば&lt;code&gt;&lt;title&gt;&lt;/code&gt;タグなどに使用できます。一方で、それ以外のデータタグは特定のウィジェット内でしか使用できません。例えば「ブログの投稿」で説明されているデータタグは、&lt;code&gt;&lt;b:widget id='Blog1' type='Blog'&gt;&lt;b:widget&gt;&lt;/code&gt;内でのみ使用できます。&lt;/p&gt;

&lt;p&gt;制御タグを用いて、ループ (繰り返し) や条件分岐を記述できます。大抵の場合、ブログのトップページに表示する記事の一覧はループを用いることになるでしょう。また、特定の条件でのみ表示させたいタグがあるとき、条件分岐を使います。これは、例えば Blogger 内での記事検索を実装するのに使えるでしょう。条件分岐には b:if, b:elseif, b:else タグを、ループには b:loop タグを使います。
&lt;pre&gt;&lt;code&gt;&lt;!-- &lt;/b:loop&gt; までを、記事の数だけ繰り返す --&gt;
&lt;b:loop var='post' values='data:posts'&gt;

  &lt;b:if cond='data:blog.pageType == "index"'&gt;
    &lt;!-- トップページや検索結果画面などで表示される --&gt;
    &lt;h2&gt;&lt;data:post.title/&gt;&lt;/h2&gt;

    &lt;!-- それ以外で表示される --&gt;
    &lt;b:else/&gt;
    &lt;h1&gt;&lt;data:post.title/&gt;&lt;/h1&gt;
    &lt;p&gt;&lt;data:post.body/&gt;&lt;/p&gt;
  &lt;/b:if&gt;

&lt;/b:loop&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;b:eval&lt;/code&gt;タグと&lt;code&gt;expr:&lt;/code&gt;属性 (&lt;a href='https://developer.mozilla.org/ja/docs/Learn/Getting_started_with_the_web/HTML_basics#Anatomy_of_an_HTML_element'&gt;Attribute&lt;/a&gt;) は特殊で難しい構文です。&lt;code&gt;eval:&lt;/code&gt;属性は、HTML の属性にブログのデータを埋め込みたいときに使用します。例えば、ブログのホームページへのリンクは次のようなものになるでしょう。
&lt;pre&gt;&lt;code&gt;&lt;a expr:href="data:homepageUrl"&gt;ホームページ&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;code&gt;b:eval&lt;/code&gt;タグも同様の役割を持ちますが、これは属性ではなくタグです。&lt;/p&gt;

&lt;p&gt;制御タグと&lt;code&gt;b:eval&lt;/code&gt;、&lt;code&gt;expr:&lt;/code&gt;についての&lt;a href='https://support.google.com/blogger/answer/46995'&gt;ヘルプページはこちら&lt;/a&gt;です。&lt;/p&gt;

&lt;h2&gt;TIPS&lt;/h2&gt;
&lt;h3&gt;SNS などへの共有時にプレビューを表示する&lt;/h3&gt;
&lt;p&gt;SNS に記事を共有したときにプレビューを表示させるには、OGP (Open Graph Protocol, &lt;a href='https://ogp.me'&gt;ogp.me&lt;/a&gt;) を使用します。
&lt;pre&gt;&lt;code&gt;&lt;html prefix='og: http://ogp.me/ns#'&gt;
  &lt;head&gt;
    &lt;meta property='og:title' content='記事のタイトル'&gt;
    &lt;meta property='og:type' content='article (トップページなら website)'&gt;
    &lt;meta property='og:site_name' content='サイト名'&gt;
    &lt;meta property='og:url' content='記事の URL'&gt;
    &lt;meta property='og:image' content='記事のサムネイル画像の URL&gt;
    &lt;meta property='og:description' content='記事の概要'&gt;
    &lt;meta property='og:locale' content='ja_JP'&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;h3&gt;読み込みを高速化する&lt;/h3&gt;

&lt;p&gt;Blogger のテーマは、そのまま書くと勝手に CSS や JavaScript を挿入されてしまいます。これらは&lt;a href='https://blog.comame.xyz/2019/04/web-performance.html'&gt;レンダリングをブロックする要因&lt;/a&gt;になり、読み込みの低速化に繋がります。もしパフォーマンスにこだわりのある方は、次のような一手間を加えてみてください。

&lt;pre&gt;&lt;code&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;

&lt;!DOCTYPE html&gt;
&lt;html b:responsive=&#039;true&#039; lang=&#039;ja&#039; xmlns=&#039;http://www.w3.org/1999/xhtml&#039; xmlns:b=&#039;http://www.google.com/2005/gml/b&#039; xmlns:data=&#039;http://www.google.com/2005/gml/data&#039; xmlns:expr=&#039;http://www.google.com/2005/gml/expr&#039;&gt;

  &lt;!-- head 開始タグ--&gt;
  &amp;lt;!--&lt;head&gt;--&amp;gt;&amp;lt;head&amp;gt;
    &lt;!-- ... --&gt;
  &lt;!-- head 終了タグ --&gt;
  &amp;lt;!--&lt;/head&gt;--&amp;gt;&amp;lt;/head&amp;gt;

  &lt;!-- body 開始タグ (変更する必要なし) --&gt;
  &lt;body&gt;
    &lt;!-- ... --&gt;
  &lt;!-- body 終了タグ --&gt;
  &amp;lt;!--&lt;/body&gt;--&amp;gt;&amp;lt;/body&amp;gt;

&lt;/html&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;
&lt;p&gt;ただし、これによって Blogger が用意している CSS が読み込まれなくなるため、公式のウィジェットは正常に機能しなくなる可能性があります。&lt;/p&gt;

&lt;h3&gt;凝りすぎない&lt;/h3&gt;

&lt;p&gt;自分のブログでしかテーマを使わないのであれば、汎用性にこだわりすぎる必要はありません。例えば、Blogger 公式テーマのように、ヘッダーやフッター、サイドバーなどのパーツに分けて、そこにウィジェットが挿入される可能性を考えて...などやっていると、軽く数日どころではなく日が暮れることになります。例えば Web に公開して誰でも使えるようなものにする、などの目的がないのであれば、「見た目が整えば OK!」という気持ちで挑むのがまずは良いと思います。これが辛いのは、後述するように公式情報が乏しいのも理由だったりするわけですけども...&lt;/p&gt;
&lt;p&gt;例えば、このブログのテーマも1つの変更不可能な巨大ウィジェットだけで構成されています。&lt;img alt='このブログの「レイアウト」画面' src="https://2.bp.blogspot.com/-WPVLWOc-Ua0/Xe2iUHPfxHI/AAAAAAABIfI/DdiyKmiU_b4Wx6WEmnZcpCQBeLeiIibEACLcBGAsYHQ/s1600/%25E3%2582%25B9%25E3%2582%25AF%25E3%2583%25AA%25E3%2583%25BC%25E3%2583%25B3%25E3%2582%25B7%25E3%2583%25A7%25E3%2583%2583%25E3%2583%2588%2B2019-12-09%2B10.24.11.png"/&gt;&lt;/p&gt;

&lt;h3&gt;公式情報はあまり当てにならない...&lt;/h3&gt;

&lt;p&gt;Advent Calendar の&lt;a href='https://outing-diary.blogspot.com/2019/12/blogger.html'&gt;前日の記事&lt;/a&gt;にも書かれていたように、テーマ作成について公式に出されている情報は非常に乏しいものになっています。英語のページですが、とてもわかり易く書かれたドキュメントが存在するため、困ったときはそちらも見てみると良いかもしれません (&lt;a href='https://sites.google.com/site/templateofdoom/Home'&gt;https://sites.google.com/site/templateofdoom/&lt;/a&gt;)。Google Developers にきちんとリファレンスを出してほしいな...&lt;/p&gt;


&lt;h2&gt;終わりに&lt;/h2&gt;
&lt;p&gt;参考に、これまでのことをまとめた最小のテンプレートを公開します。&lt;a href='https://gist.github.com/comame/4556f8b06a8b34de688cb7cd454452d7'&gt;GitHub Gist&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Blogger のテーマを作成するには、ループや条件分岐など、いくらか高度な概念を用いることになります。確かにやや難易度は高いですが、自作のテーマが完成した時は嬉しいですし、何より深い愛着が湧くものです。自分のブログを開くたびに少し嬉しくなるような、そんな素敵なテーマが完成することを祈っています。&lt;/p&gt;
&lt;p&gt;次の記事は minato さんです。楽しい Blogger ライフを！&lt;/p&gt;
</content>
    </entry>
    
    <entry>
      <title>Google のエキスパートとして回答すること</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2019-12-01/google-expert' />
      <id>https://blog.comame.xyz/entries/2019-12-01/google-expert</id>
      <updated>2019-12-01T00:00:00Z</updated>
      <content type='html'>&lt;p&gt; &lt;a href='https://adventar.org/calendars/4226'&gt;Google Products Advent Calendar 2019&lt;/a&gt; の 1 日目の記事です。&lt;/p&gt;


&lt;p&gt;こんな記事が初日を飾るのも申し訳ない気がしますが、私が数年間ヘルプコミュニティで回答してきた中で、なぜ自分は回答を続けているんだろう、ということを考えてみたポエムです。&lt;/p&gt;

&lt;h2&gt;Google Product Experts とは&lt;/h2&gt;
&lt;p&gt; Google Product Experts (PE) は、Google の&lt;a href='https://support.google.com/'&gt;ヘルプコミュニティ&lt;/a&gt;に日々投稿される質問に回答するユーザーのことです。コミュニティには、日々たくさんの質問が寄せられます。中にはよくある質問から、誰にも解決策が見つからないような問題まで投稿されます。&lt;/p&gt;
&lt;p&gt;エキスパートは、全員がパソコンの前に座り続けている技術オタクというわけではありません (私はそうかもしれませんが)。様々な職業・立場・趣味の人が回答しています。&lt;/p&gt;


&lt;h2&gt;なぜ回答し続けるのか&lt;/h2&gt;

&lt;p&gt; これはエキスパートによって答えが変わるでしょう。なぜ回答し続けるのか、というのは非常に難しい問いになり得ます。&lt;/p&gt;
&lt;p&gt;Help on Social という取り組みがありました (14 日目の yasu0796 さんの記事をお楽しみに！)。これは、Twitter 上で困っていそうな人を見つけ、リプライで回答をするものです。#gHelp のハッシュタグでご存じの方もいるかもしれません。Twitter でいきなりリプライを飛ばすという性質上、極稀に罵倒されるようなこともありました。これは Twitter に限ったことではありません。Google のコミュニティでも、直接的な表現で投稿するユーザーは存在します。回答者も人間ですから、当然嫌な気持ちになります。それでも、エキスパートは回答を続けます。なぜでしょうか。&lt;/p&gt;
&lt;p&gt;エキスパートになることによって得られる特典でしょうか。ベータテストに参加できたり、イベントに参加できたりと、特典は嬉しいものがあります。では、もし仮に明日からこれらの特典を一切受けられなくなるとしたら、エキスパートは回答をやめるでしょうか。おそらく、多くのエキスパートは回答をやめることはないと思います。少なくとも僕は回答をやめません (Googler と連絡が取れなくなるのは、エスカレーションできなくてとても困るけど)。特典があるから回答を続ける、というのは不適切でしょう。&lt;/p&gt;
&lt;p&gt;正直なところ、少なくとも私にとって習慣になってしまったから、というのは1つの正解なのかもしれません。朝起きたらコミュニティをチェックする、仕事が終わったら返信が来ていないか確認する、といったように、日々のルーティンに組み込まれているエキスパートもいるかもしれません。では、習慣になったから惰性で回答を続けているのでしょうか。エキスパートの皆さんの回答を見ていると、これも不適切です。&lt;/p&gt;
&lt;p&gt;おそらく、最終的には「好きだから」「楽しいから」「色んな人に使ってほしいから」「知識を広めたいから」という理由に行き着くでしょう。Google の製品について日々真剣に議論し、アップデート情報に一喜一憂し、Google にフィードバックを送りまくるエキスパートの姿を見ていると、そう結論づけるのが妥当に思えます。&lt;/p&gt;


&lt;h2&gt;質問に答えるということ&lt;/h2&gt;

&lt;p&gt;質問に答えることによって質問者を助けるだけではなく、自分が得られるものも非常に大きいということが言えます。自身が回答することでより深い知識を得られる、他の回答者と交流できる、問題を解決したときの達成感を得られる、など様々なことが挙げられます。回答することでなにか得ることを目的にしているわけではないのに、「与えよ、さらば与えられん」とはよく言ったものです (旧 Top Contributor Program の日本語ページに書いてあった気がします、確か)。&lt;/p&gt;


&lt;h2&gt;&lt;/h2&gt;

&lt;p&gt;Google の製品が好きな方、質問に答えるのが好きな方、ぜひヘルプコミュニティへの投稿をお待ちしています。次は仁田坂 淳史さんによる Inbox なき後のメール管理についての記事です。お楽しみに！&lt;/p&gt;
</content>
    </entry>
    
    <entry>
      <title>Catalina で Chrome の画面共有が使用できない問題</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2019-11-04/catalina-chrome-screen-share' />
      <id>https://blog.comame.xyz/entries/2019-11-04/catalina-chrome-screen-share</id>
      <updated>2019-11-04T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;macOS 10.15 Catalina において、Chrome の画面共有が使用できない問題が発生しています。これにより、例えば Hangout で手元の画面を映すことできなくなってしまいます。&lt;/p&gt;

&lt;h2&gt;原因&lt;/h2&gt;
&lt;p&gt;Catalina でアプリケーションが画面を取得するには、ユーザーによる許可が必要です（システム環境設定 &gt; セキュリティとプライバシー &gt; プライバシー &gt; 画面収録 で設定)。Chrome 78 では、ユーザーが画面収録を許可していても、権限がないものとして扱ってしまうようです。&lt;/p&gt;

&lt;h2&gt;今後どうなるか&lt;/h2&gt;
&lt;p&gt;Chrome Canary 80.0.3955.4 ではこの問題が解決されていることを確認できました。今後のアップデートで修正されると思われます。&lt;/p&gt;

&lt;a href='https://bugs.chromium.org/p/chromium/issues/detail?id=993692'&gt;Issue Tracker&lt;/a&gt;
</content>
    </entry>
    
    <entry>
      <title>Unlimited Mirai に参加しました</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2019-10-30/unlimited-mirai' />
      <id>https://blog.comame.xyz/entries/2019-10-30/unlimited-mirai</id>
      <updated>2019-10-30T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;2019年10月29日に開催された&lt;a href='https://www.waseda.jp/inst/icc/news/2019/09/04/10146/'&gt;Unlimited Mirai&lt;/a&gt;に参加しました。&lt;/p&gt;

&lt;h2&gt;本編&lt;/h2&gt;
&lt;p&gt;クリプトン創設者の伊藤博之さんによる1時間の講演でした。クリプトンにとって初音ミクとは何であるか、どのような存在にしたいのかといったような内容でした。&lt;/p&gt;

&lt;h3&gt;初音ミク&lt;/h3&gt;
&lt;p&gt;初音ミクは仮想楽器であり、キャラクターでもある。仮想楽器 (Virtual Instruments) は、本物の楽器と異なり、個人で扱うことが容易である。&lt;/p&gt;

&lt;h3&gt;ビジネスにおける新規性&lt;/h3&gt;
&lt;p&gt;音声合成技術 (Text to Speech) とコンピュータミュージックは、それぞれ単独では特に新規性のあるものではない。一方で、2つを組み合わせた歌唱合成技術は今までになかったジャンルである。そこにキャラクターを組み合わせたのが初音ミク。&lt;/p&gt;

&lt;h3&gt;創作の連鎖・デジタルコンテンツは使えば使うほど価値が増える (いかに見てもらうか)&lt;/h3&gt;
&lt;p&gt;創作物を囲い込んで無断使用とみなすのではなく、創作の連鎖を共感 (使ってくれてありがとう) の連鎖にしたい。&lt;br&gt;
著作権に絡んだ問題によって創作の連鎖を萎縮させたくないという思いから、&lt;a href='https://piapro.jp/license/pcl/summary'&gt;ピアプロ・キャラクター・ライセンス&lt;/a&gt;と&lt;a href='https://piapro.jp'&gt;ピアプロ&lt;/a&gt;を用意。クリエイターには様々な人がいるため、簡単に内容をつかめるよう PCL は要約したものを正文に加えて表示している。また、創作の連鎖を生み出すために、ピアプロの利用規約には投稿物の2次創作を許可する項目を設けてある。&lt;br&gt;
また、初音ミクをサブカルチャーの分野に限定しないために、様々なジャンルのものとコラボしている (ファッションや伝統芸能など)。マジカルミライでは、創作体験を得られるワークショップを開催している。雪ミクは、公募したミクのデザインから、ラッピング電車やグッズ販売など広げている。&lt;/p&gt;

&lt;h3&gt;コンテンツと技術の両面に明るいことを活かす&lt;/h3&gt;
&lt;p&gt;クリプトンでは、スタッフによる研究開発を行っている。素早い準備と撤収が求められるレディー・ガガの前座や、冨田勲のイートハーヴ交響曲やマジカルミライ2019などで使った現実に合わせて初音ミクを動かす技術を作った。また、不自然だった初音ミクの喋りのシステムも作った。&lt;/p&gt;

&lt;h2&gt;質疑応答&lt;/h2&gt;
&lt;p&gt;会場では30分ほど質疑応答が設けられました。&lt;/p&gt;

&lt;h3&gt;初音ミクを盛り上げるために、挑戦したいことは？&lt;/h3&gt;
&lt;p&gt;ミク自体は意思を持たないので、クリエイターがやりたいことを代弁できるようにしていきたい。&lt;/p&gt;

&lt;h3&gt;PCL では人を傷つけるコンテンツを禁止しているが、実際には死を連想させるような作品もある&lt;/h3&gt;
&lt;p&gt;PCL の目的は創作を萎縮させないことである。どのコンテンツは良くて何が悪いかの線引きは難しいので、ファンに一任している。&lt;/p&gt;

&lt;h3&gt;音を扱うクリプトンを立ち上げたきっかけは？&lt;/h3&gt;
&lt;p&gt;楽器をやっていたから。皆さんと違わない。&lt;/p&gt;

&lt;h3&gt;今後クリプトンがやっていきたいことは？&lt;/h3&gt;
&lt;p&gt;ソフトウェアとしての初音ミクができること (機能) の向上によって、クリエイターができることを増やしたい。創作の方向性についてはクリプトンとしてできることはない。&lt;/p&gt;

&lt;h3&gt;クリプトンの新社員に求めることは？&lt;/h3&gt;
&lt;p&gt;社員のやりたいことの積み重ねが会社なので、何がしたいかを大事にしている。&lt;/p&gt;

&lt;h3&gt;コラボしていくなかでの困難をどう乗り越えた？&lt;/h3&gt;
&lt;p&gt;初音ミクは通常のアーティストと異なり楽器なので、業界的な違和感もあった。伝統芸能やクラシックに参加するのは大変だったが、サブカルチャーに限らない幅広い分野に初音ミクを広げていく。&lt;/p&gt;

&lt;h3&gt;初音ミクより前に発売されたメイコ・カイトではなく、なぜ初音ミクがヒットしたのか？&lt;/h3&gt;
&lt;p&gt;ニコニコ動画や YouTube などの動画共有サイトの存在が大きい。メイコやカイトが出た頃は、創作物を音楽のコミュニティに投稿するしかなかった。一方初音ミクは音楽だけではなく動画をつけることができた。&lt;/p&gt;

&lt;h3&gt;ビジネスとアートをどうやって統合した？&lt;/h3&gt;
&lt;p&gt;初音ミクのモチーフを特定の分野だけにせず、様々な分野に存在を拡散したかった。陳腐化した伝統に初音ミクを入り込ませる。&lt;/p&gt;

&lt;h3&gt;技術が進歩すればもっと人の声に寄せられるはず。初音ミクをもっと人に近づけたいか、あえて機械的な面を残したいか？&lt;/h3&gt;
&lt;p&gt;リアルを突き詰めることは技術的には可能である。初音ミクを声優のクローンにせず、ミクっぽさを残すべきなのではないか？音色やイントネーションは改善すべきだが、ある種のたどたどしさ・機械らしさを残している部分はある。&lt;/p&gt;

&lt;h2&gt;まとめ・その他&lt;/h2&gt;
&lt;p&gt;創作の連鎖を大切にすること、特定の分野に限定しないことが強調されていました。動画から始まりイラストや 3DCG など幅広い分野に広まっていった背景を踏まえたからこその発想なのかなというように思います。&lt;/p&gt;
&lt;p&gt;当日は Twitter で内容を実況していた方もいました。&lt;a href='https://twitter.com/search?q=%23UnlimitedMirai'&gt;#UnlimitedMirai&lt;/a&gt;&lt;br&gt;
講演の中で紹介された &lt;a href='https://youtu.be/MGt25mv4-2Q'&gt;Google Chrome の広告&lt;/a&gt;。創作の連鎖を表現する動画で、Everyone, Creator のキャッチフレーズが印象的です。&lt;/p&gt;
</content>
    </entry>
    
    <entry>
      <title>Let's Encrypt (Certbot) でワイルドカード証明書を取得できないときの解決法</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2019-10-03/letsencrypt-wildcard-error' />
      <id>https://blog.comame.xyz/entries/2019-10-03/letsencrypt-wildcard-error</id>
      <updated>2019-10-03T00:00:00Z</updated>
      <content type='html'>&lt;h2&gt;発生する問題&lt;/h2&gt;
&lt;p&gt;Certbot でワイルドカード証明書を発行しようとしたときに&lt;code&gt;The currently selected ACME CA endpoint does not support issuing wildcard certificates&lt;/code&gt;というお叱りを受ける。&lt;/p&gt;

&lt;h2&gt;解決方法&lt;/h2&gt;
&lt;p&gt;ACME v2 のエンドポイントを直接指定してやれば良い。
&lt;pre&gt;&lt;code&gt;$ certbot certonly --server https://acme-v02.api.letsencrypt.org/directory&lt;/code&gt;&lt;/pre&gt;
Let's Encrypt のエンドポイントは&lt;a href='https://letsencrypt.org/ja/docs/acme-protocol-updates/'&gt;このドキュメント&lt;/a&gt;に記載されている。&lt;/p&gt;
</content>
    </entry>
    
    <entry>
      <title>AdSense の申請が落ちた理由？</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2019-09-27/why-fail-adsense' />
      <id>https://blog.comame.xyz/entries/2019-09-27/why-fail-adsense</id>
      <updated>2019-09-27T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;結論を先に述べると、AdSense の審査は無事に通過しました。1度審査に落ちたため、その理由と思われるものを残しておこうと思います。&lt;p&gt;

    &lt;h2&gt;落ちた原因の仮説&lt;/h2&gt;
    &lt;p&gt;はじめに審査に落ちた理由は「コンテンツの不足」でした。しかしこのブログにはすでに20ほど記事があり、またユーザーにとって無意味なコンテンツではないと思われます (少なくともそう思いたい)。そのため、ドメインを変更する前のデータを Google が何らかの原因で持っていて、参照しているのではないかという仮説を立てました。&lt;br&gt;
    ドメインを変更する経緯は&lt;a href=/entries/2019-09-24/apply-adsense.html&gt;こちら&lt;/a&gt;に書いてあります。&lt;/p&gt;

    &lt;h2&gt;仮説の検証・対処&lt;/h2&gt;
    &lt;p&gt;Google が持っているキャッシュの中でも、心当たりがあったのは Google 検索のインデックスでした。現在のインデックス状況を調べるために、Search Console の URL 検査を https://comame.xyz/ に行いました。そうすると、確かに変更前のものがインデックスされていることを確認できました。&lt;br&gt;
    そこで、検索のインデックスを更新させるために、インデックスの登録リクエストを送信しました。&lt;/p&gt;

    &lt;h2&gt;結果&lt;/h2&gt;
    &lt;p&gt;1日ほどインデックスに登録されるのを待ち、再度 URL 検査でブログがインデックスされていることを確認しました。その後再び AdSense の申請を行いました。その結果、無事に審査を通過しました。&lt;/p&gt;

    &lt;h2&gt;疑問点&lt;/h2&gt;
    &lt;p&gt;この仮説に対して、1点疑問が残ります。AdSense の審査をするときに、Google が指定する JavaScript のコードを Web ページに埋め込む必要があります。しかし、Google が元々インデックスしていたページには当然スクリプトを埋め込んでいませんでした。審査に落ちた理由はあくまでコンテンツの不足であり、指定するコードが見つからなかったことではありませんでした。&lt;/p&gt;
</content>
    </entry>
    
    <entry>
      <title>OpenSSL で自己証明書を作成する方法</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2019-09-26/self-signed-certificate' />
      <id>https://blog.comame.xyz/entries/2019-09-26/self-signed-certificate</id>
      <updated>2019-09-26T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;開発鯖用に毎回 Let's Encrypt で発行するのめんどいので、自分で発行しようと思った&lt;/p&gt;

&lt;h2&gt;通常の証明書&lt;/h2&gt;

&lt;p&gt;
&lt;pre&gt;&lt;code&gt;$ openssl genrsa -aes256 2048 &gt; server.key
$ openssl req -new -key server.key &gt; server.csr  # Certificate Signing Request
$ openssl x509 -req -days 90 signkey server.key &lt; server.csr &gt; server.crt&lt;/code&gt;&lt;/pre&gt;
&lt;/p&gt;

&lt;h2&gt;複数の Common Name に対応する&lt;/h2&gt;
&lt;p&gt;
&lt;pre&gt;&lt;code&gt;$ cat &gt; altNames.txt
subjectAltName = DNS:foo.example.com, DNS:bar.example.com

$ openssl x509 -req -days 90 -signkey server.key -extfile altNames.txt &lt; server.csr &gt; server.crt
&lt;/code&gt;&lt;/pre&gt;

&lt;/p&gt;

&lt;h2&gt;CSR を確認する&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ openssl req -in server.csr -noout -text&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;証明書の内容 (あるいは期限のみ) を確認する&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ openssl x509 -in server.crt -noout -text [-dates]&lt;/code&gt;&lt;/pre&gt;
</content>
    </entry>
    
    <entry>
      <title>AdSense の申請をした</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2019-09-24/apply-adsense' />
      <id>https://blog.comame.xyz/entries/2019-09-24/apply-adsense</id>
      <updated>2019-09-24T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;今日このブログで AdSense の申請をしましたが、いくつか技術的な問題があったため、それの対処法を紹介します。&lt;/p&gt;

&lt;h2&gt;発生した問題&lt;/h2&gt;
&lt;p&gt;AdSense の申請をするには当然対象の URL が必要ですが、サブドメインでは申請できないという問題があります。このブログは blog.comame.xyz で配信していましたが、comame.xyz に付け替える必要がありました。&lt;br&gt;
一方、comame.xyz はすでに自前のサーバに割り当てていました。このブログで使用している一部の画像やスクリプトなども comame.xyz から取得していました。そのため、DNS を書き換えるだけではブログのレイアウトが崩れてしまいます。&lt;/p&gt;

&lt;h2&gt;状況&lt;/h2&gt;
&lt;p&gt;comame.xyz 上では、すでにいくつかのサービスが動いています。一方で、過去に Docker を使用することで複数のサーバに分割させており、Nginx のリバースプロキシを使ってリクエストを振り分けていました。実際の Nginx のコンフィグの一部は以下のようになっていました。&lt;p&gt;
&lt;pre&gt;&lt;code&gt;
server {
  location / {
    location / {
       # Docker Compose のサービスの1つとしてホームページを配信していた
       proxy_pass http://home/;
    }
    location /assets {
      # 画像や CSS、JavaScript はここから配信していた
      proxy_pass http://assets/;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この設定ファイルからわかるように、アセット配信サーバとホームページ配信サーバは別のコンテナで実行していました。&lt;/p&gt;


&lt;h2&gt;解決策&lt;/h2&gt;
&lt;p&gt;ルートディレクトリだけを blog.comame.xyz へのリバースプロキシとすることで解決しました。アセット配信サーバは変わらず /assets で配信しています。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
server {
    location / {
        location / {
            # 今まではコンテナに向けていたものを、blog.comame.xyz に差し替え
            proxy_pass: https://blog.comame.xyz/;

            # TLS 周りのエラーが発生したので
            proxy_ssl_server_name on;
        }
        location /assets {
            # 変更なし
            proxy_pass: http://assets/;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;現状&lt;/h2&gt;
&lt;p&gt;DNS をいじったわけではないので、blog.comame.xyz にアクセスすることでもブログにアクセスできます。comame.xyz にアクセスすると、今まで表示されていたホームページではなく、ブログが表示されるようになっています。&lt;br&gt;
次のような流れになっています。&lt;br&gt;
&lt;code&gt;User Agent -&gt; comame.xyz -(Nginx が代理アクセス)-&gt; blog.comame.xyz&lt;/code&gt;
&lt;/p&gt;

&lt;h2&gt;教訓&lt;/h2&gt;
&lt;p&gt;止めると影響が大きいサーバとそうでもないサーバは、分けておいたほうが後々役に立つ (適当)&lt;br&gt;
AdSense の申請通るといいな&lt;/p&gt;
</content>
    </entry>
    
    <entry>
      <title>Ubuntu ユーザー作成</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2019-09-18/ubuntu-create-user' />
      <id>https://blog.comame.xyz/entries/2019-09-18/ubuntu-create-user</id>
      <updated>2019-09-18T00:00:00Z</updated>
      <content type='html'>&lt;ol&gt;
    &lt;li&gt;&lt;code&gt;adduser [user]&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;&lt;code&gt;gpasswd -a [user] [group]&lt;/code&gt;&lt;/li&gt;
    &lt;/ol&gt;
</content>
    </entry>
    
    <entry>
      <title>Rootless Docker のインストール方法</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2019-09-13/install-rootless-docker' />
      <id>https://blog.comame.xyz/entries/2019-09-13/install-rootless-docker</id>
      <updated>2019-09-13T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;今更感は否めないが、備忘録も兼ねて&lt;/p&gt;

&lt;h2&gt;手順&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;https://get.docker.com/rootless&lt;/code&gt;からシェルスクリプトをダウンロードする&lt;/li&gt;
&lt;li&gt;実行する&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$HOME/bin/dockerd-rootless.sh --experimental --storage-driver vfs&lt;/code&gt;を実行する
&lt;/ol&gt;

&lt;h2&gt;補足&lt;/h2&gt;

&lt;p&gt;インストールスクリプトを覗いてみたところ、どうやら自動的に Service を作成してくれるらしい。&lt;/p&gt;

&lt;h2&gt;ドキュメント&lt;/h2&gt;
&lt;a href='https://github.com/moby/moby/blob/master/docs/rootless.md'&gt;https://github.com/moby/moby/blob/master/docs/rootless.md&lt;/a&gt;
</content>
    </entry>
    
    <entry>
      <title>comame.xyz を ConoHa に移した</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2019-07-11/migrate-to-conoha' />
      <id>https://blog.comame.xyz/entries/2019-07-11/migrate-to-conoha</id>
      <updated>2019-07-11T00:00:00Z</updated>
      <content type='html'>このはちゃんかわいい


&lt;h2&gt;Docker&lt;/h2&gt;

今回は、Web サーバを Docker でコンテナに包んでみました。デプロイが圧倒的に簡単になりました。&lt;br&gt;
今まではマネージドサービスと自分でサーバを管理するのとの間で振り子のように動いていましたが、これからは移動も楽になる気がします。


&lt;h2&gt;速度&lt;/h2&gt;

今までは Firebase Hosting の US リージョンに置いていたため、RTT が 300 ms くらいありました。流石に堪えられないなーと思っていたのが ConoHa に移した大きな理由の一つです。ConoHa は東京にリージョンがあるので、とてもはやいです (小並感)。


&lt;h2&gt;開発のしやすさ&lt;/h2&gt;

今回は Nginx もコンテナに閉じ込めたので、リモートマシンでも完全に同じ環境でサーバを起動できるようになりました。これにより、今まではサーバにアップロードしないと確認できなかったようなこと (Secure Context で動く API とか) もローカル環境で手軽にできるようになりました。

&lt;h2&gt;改善したい点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;ログ設定をきちんとしていないので、コンテナを止めるとログも消えてしまう&lt;/li&gt;
  &lt;li&gt;Nginx の proxy_pass でサービス名を直に指定しているので、すべてのコンテナを立ち上げないとエラーを吐いてしまう&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;&lt;/h2&gt;
このはちゃんかわいい
</content>
    </entry>
    
    <entry>
      <title>Web ページの読み込みパフォーマンスを改善する</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2019-04-23/improve-web-performance' />
      <id>https://blog.comame.xyz/entries/2019-04-23/improve-web-performance</id>
      <updated>2019-04-23T00:00:00Z</updated>
      <content type='html'>&lt;h2&gt;
    TL;DR&lt;/h2&gt;
    &lt;ol&gt;
    &lt;li&gt;レンダリングブロッキング要素を減らす&lt;ol&gt;
    &lt;li tabbing="1"&gt;&lt;script&gt;&lt;/li&gt;
    &lt;li tabbing="1"&gt;&lt;link rel="stylesheet"&gt;&lt;/li&gt;
    &lt;/ol&gt;
    &lt;/li&gt;
    &lt;li&gt;Web フォントのロードを制御する&lt;/li&gt;
    &lt;li&gt;画像を最適化する&lt;/li&gt;
    &lt;li&gt;地理的に近い場所にサーバを置く&lt;/li&gt;
    &lt;/ol&gt;
    &lt;h2&gt;
    レンダリングブロッキング要素を減らす&lt;/h2&gt;
    ブラウザのレンダラは、HTML を上から順に (ファイルに記述してある順に) 解釈して DOM を構築します。途中で JavaScript や CSS が埋め込まれている場合は、スクリプトの実行やスタイルの計算が終わるまで DOM の構築は中断されます。これをレンダリングブロッキングと呼びます。&lt;br /&gt;
    &lt;h3&gt;
    &lt;script&gt;&lt;/h3&gt;
    最も効果的な対処法は、&lt;code&gt;async&lt;/code&gt;属性をつけることです。&lt;code&gt;async&lt;/code&gt;属性が付与されたスクリプトは、DOM の構築を妨げません。特に、外部リソースを取得するような場合に効果が発揮されます。&lt;br /&gt;
    一方で、複数の&lt;code&gt;&lt;script&gt;&lt;/code&gt;タグにそれぞれ&lt;code&gt;async&lt;/code&gt;属性が付与されていた場合、実行順序が保証されないことに注意が必要です。&lt;code&gt;HTMLScriptElement.onload&lt;/code&gt; イベントを活用するのが良いでしょう。&lt;br /&gt;
    &lt;h3&gt;
    &lt;link rel="stylesheet"&gt;&lt;/h3&gt;
    &lt;code&gt;&lt;script&gt;&lt;/code&gt;タグの場合は&lt;code&gt;async&lt;/code&gt;属性をつけるだけで済みましたね。しかし、&lt;code&gt;&lt;link&gt;&lt;/code&gt; タグには非同期に読み込ませるような属性は存在しません。そのため、JavaScript を使用して非同期に読み込ませるような処理を書くことになります。&lt;br /&gt;
    &lt;pre&gt;&lt;code&gt;&lt;head&gt;
     &lt;noscript id="async-styles"&gt;
      &lt;link rel="stylesheet" href="style.css"&gt;
     &lt;/noscript&gt;
     &lt;script&gt;
      window.requestAnimationFrame(() =&gt; {
       document.head.innerHTML +=
        document.getElementById('async-styles').textContent;
      });
     &lt;/script&gt;
    &lt;/head&gt;&lt;/code&gt;&lt;/pre&gt;
    あるいは、&lt;code&gt;&lt;style&gt;&lt;/code&gt; タグを使用して HTML に埋め込んでしまうのも有効です。ただし、再利用性が低いこと、Contents Security Policy との相性が悪いことに注意が必要です。&lt;br /&gt;
    &lt;br /&gt;
    実際のところ、レンダリングブロックする要素を減らすだけでも相当な効果が見込めます。適切にレンダリングブロックを制御した場合、リソースのダウンロードがすべて完了していなくとも必要最低限の要素だけ表示させることができます。&lt;br /&gt;
    一方で、JavaScript の実行が必須な Web アプリケーションの場合、表示されているのに操作できない時間が発生することになります。このような場合は、ローディングアニメーションを表示するか、あるいは意図的にレンダリングブロックを発生させるという手段も選択肢となり得るでしょう。&lt;br /&gt;
    &lt;h2&gt;
    Web フォントのロードを制御する&lt;/h2&gt;
    Web フォントというのはとても便利なものです。導入が簡単にもかかわらず、Web ページの印象を大きく変えてくれます。&lt;br /&gt;
    しかし、無頓着に Web フォントを使うのは考えものです。ネットワークの速度が遅い環境では、Web フォントのロードが終わるまで文字が表示されないかもしれません。(みなさんも経験ありませんか？) 酷い場合にはユーザーを5秒以上待たせてしまうこともあります。&lt;br /&gt;
    &lt;br /&gt;
    これは CSS ファイルにほんの数行付け足すだけで解決できます。&lt;br /&gt;
    &lt;pre&gt;&lt;code&gt;@font-face {
     /* ... */
     font-display: swap;
    }&lt;/code&gt;&lt;/pre&gt;
    この 1 行を付け足すだけで、ブラウザは Web フォントがロードされるまでは、オフラインで使用可能な他のフォントで代わりに表示してくれます！&lt;br /&gt;
    &lt;h2&gt;
    画像を最適化する&lt;/h2&gt;
    Web ページの平均サイズはどんどん巨大化しています。そして、そのうちの大部分を画像が占めています。&lt;br /&gt;
    画像のファイルサイズを少しでも減らすことができれば、きっともう少しページの読み込みが早くなることでしょう。&lt;br /&gt;
    WebP など最新のフォーマットを有効活用しましょう。フォーマットに気を配るだけで、ファイルサイズを大幅に削減できます。&lt;br /&gt;
    &lt;code&gt;&lt;picture&gt;&lt;/code&gt;タグを使って複数のフォーマットの画像を選択できるようにすれば、最新のフォーマットに対応していないようなブラウザでも正常に画像を表示させることができます。&lt;br /&gt;
    &lt;h2&gt;
    最後に&lt;/h2&gt;
    これらの対策を施したら、最適化の効果の程を確かめてみましょう。&lt;br /&gt;
    Chrome ブラウザを使用しているのであれば、DevTools の Audits タブでパフォーマンスを調査できます。&lt;br /&gt;
    また、&lt;a href="https://developers.google.com/speed/pagespeed/insights/?hl=ja" rel="noopener" target="_blank"&gt;PageSpeed Insights&lt;/a&gt; を使用するのもおすすめです。&lt;br /&gt;
    &lt;br /&gt;
    ここに紹介した以外にもたくさんの高速化の手法があります。調べてみると良いでしょう。&lt;br /&gt;
    &lt;ul&gt;
    &lt;li&gt;Resource Hints&lt;/li&gt;
    &lt;li&gt;Service Worker + Cache API&lt;/li&gt;
    &lt;li&gt;Lazy Load (Intersection Observer v2 とかいい感じに使えそう)&lt;/li&gt;
    &lt;li&gt;レイアウトを静的に指定する&lt;/li&gt;
    &lt;li&gt;AMP (Accelerated Mobile Pages)&lt;/li&gt;
    &lt;li&gt;SSR (Server Side Rendering)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;h2&gt;2019/07/04 追記&lt;/h2&gt;
    上にメモした Lazy Loading ですが、Chrome に&lt;code&gt;loading&lt;/code&gt;属性が追加されました。まだ実用段階ではなさそうですが、注目していきたいです。

    &lt;h2&gt;2019/07/10 また追記&lt;/h2&gt;
    今まで Google Compute Engine の US リージョンに置いていましたが、ConoHa の東京リージョンに置くようにしたらめちゃくちゃ速度が改善しました。&lt;br&gt;
    地理的な要因も見過ごせませんね。

    &lt;!-- スタイルを確定させる --&gt;
</content>
    </entry>
    
    <entry>
      <title>Safari のブックマークを Chrome にインポートできない問題</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2019-04-22/safari-bookmark-import' />
      <id>https://blog.comame.xyz/entries/2019-04-22/safari-bookmark-import</id>
      <updated>2019-04-22T00:00:00Z</updated>
      <content type='html'>現在、macOS 10.14 Mojave において、Safari のブックマークを Chrome にインポートできない問題が発生しているようです。&lt;br /&gt;
&lt;h2&gt;
問題が発生しうる環境&lt;/h2&gt;
macOS 10.14 Mojave がインストールされたすべてのコンピュータ&lt;br /&gt;
&lt;h2&gt;
現象の回避方法&lt;/h2&gt;
HTML でブックマークを書き出し、Chrome にインポートする。&lt;br /&gt;
&lt;ol&gt;
&lt;li&gt;Safari を開き、「ファイル」&gt;「ブックマークの書き出し」を実行してください。&lt;/li&gt;
&lt;li&gt;Chrome の設定画面を開いてください。&lt;/li&gt;
&lt;li&gt;「ブックマークと設定のインポート」を開き、インポート先を「HTML ファイルをブックマークに登録」に指定してください。&lt;/li&gt;
&lt;li&gt;「ファイルを選択」ボタンを押し、手順  1 でエクスポートしたファイルを選択してください。&lt;/li&gt;
&lt;/ol&gt;
&lt;div&gt;
&lt;h2&gt;
原因&lt;/h2&gt;
&lt;/div&gt;
&lt;div&gt;
macOS のセキュリティ機能が原因のようです。&lt;/div&gt;
&lt;div&gt;
現在 Chrome は Safari のブックマークが保存してあるデータベースを直に読み出すようになっています。しかし、Mojave では Safari の閲覧履歴や Cookie を含む機密データを他のアプリケーションが読み取れないような変更が加えられたため、正常にブックマークをインポートできない問題が発生しています。&lt;/div&gt;
&lt;div&gt;
&lt;h2&gt;
現在の対応状況&lt;/h2&gt;
&lt;/div&gt;
&lt;div&gt;
Apple からの情報待ちのようです。&lt;/div&gt;
&lt;div&gt;
&lt;h2&gt;
参照&lt;/h2&gt;
&lt;/div&gt;
&lt;div&gt;
Issue 850225: Mojave: Review importers from other browsers&lt;/div&gt;
&lt;div&gt;
&lt;a href="https://bugs.chromium.org/p/chromium/issues/detail?id=850225" rel="noopener" target="_blank"&gt;https://bugs.chromium.org/p/chromium/issues/detail?id=850225&lt;/a&gt;&lt;/div&gt;
</content>
    </entry>
    
    <entry>
      <title>Macbook Pro を買いました</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2019-03-12/macbook-pro' />
      <id>https://blog.comame.xyz/entries/2019-03-12/macbook-pro</id>
      <updated>2019-03-12T00:00:00Z</updated>
      <content type='html'>&lt;b&gt;やったぜ！！！！！！！！！！！&lt;/b&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
これで Windows, Mac, Chrome OS が揃いました。&lt;br /&gt;
もうちょっと使ってみてからそのうちきちんとしたレビューを書くかもしれません。おそらく。きっと。
</content>
    </entry>
    
    <entry>
      <title>ただいま Firebase Hosting</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2019-02-04/firebase-hosting' />
      <id>https://blog.comame.xyz/entries/2019-02-04/firebase-hosting</id>
      <updated>2019-02-04T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;
    comame.xyz を Google Compute Engine から Firebase Hosting に戻しました。やはり、自動ですべてを管理してくれるのは便利なものですね。&lt;br&gt;
    Cloud Functions と接続できるので、今まで Node.js で処理していたものも簡単に移植できました。Cloud Functions も Express ベースなので、コードはほとんどそのままでした。&lt;br&gt;
    &lt;br&gt;
    ただし、HTTP ヘッダを自由に書き換えられないのは盲点でした。firebase.json で書き換えることはできるようなのですが、HSTS Preload だけは諦めるしかなさそうです。標準で HSTS は設定されているので、それで妥協することにします。
    &lt;br&gt;
    自分で Linux サーバを動かすのはとても勉強になりますが、静的なファイルを配信するだけであれば、既存のサービスを使ってしまうのがどうしても楽ですね。
&lt;/p&gt;
</content>
    </entry>
    
    <entry>
      <title>Windows 10 の Media Creation Tool で USB インストールメディアの作成に失敗する</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2019-01-25/windows10-install-media' />
      <id>https://blog.comame.xyz/entries/2019-01-25/windows10-install-media</id>
      <updated>2019-01-25T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;Windows 10 の Media Creation Tool で USB インストールメディアの作成に失敗するなあ、と思っていたら、予想外のところに理由があったようです。すでに同じようなことを書いてある記事がたくさんありますが、備忘録程度に。&lt;/p&gt;

&lt;h2&gt;問題&lt;/h2&gt;
&lt;p&gt;USB メモリに Windows のインストールメディアを作成しようとすると、「失敗しました」のようなエラーが表示されてしまう。&lt;/p&gt;

&lt;h2&gt;解決方法&lt;/h2&gt;
&lt;p&gt;あらかじめ USB メモリを NTFS でフォーマットしておく。explorer.exe のクイックフォーマットで問題なし。&lt;p&gt;

&lt;h2&gt;&lt;/h2&gt;
&lt;p&gt;どうせ NTFS でフォーマットしないと書き込めないのならば、Media Creation Tool 側で自動的にフォーマットしてくれればいいのになあと思いました。&lt;p&gt;
</content>
    </entry>
    
    <entry>
      <title>USB セキュリティキーを買った</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2019-01-15/usb-security-key' />
      <id>https://blog.comame.xyz/entries/2019-01-15/usb-security-key</id>
      <updated>2019-01-15T00:00:00Z</updated>
      <content type='html'>&lt;img src="https://4.bp.blogspot.com/-K7VZSb9bU4I/XD2o-Aew2TI/AAAAAAABDRo/aOmdBYpSjPcWL7bdHBt-ON64j1rsMxN_QCKgBGAs/s1600/IMG_20190115_181149.jpg"&gt;

&lt;p&gt;2 段階認証を楽にしたいと思って飛天の e-Pass FIDO-NFC を購入しました。&lt;br&gt;
Google Authenticator などのコード表示アプリからコードをコピペしなくても、キーを USB ポートに入れるだけでログインできるようになります。フィッシング攻撃に対しても非常に有効です。&lt;/p&gt;

&lt;h2&gt;サービスごとの対応状況&lt;/h2&gt;
&lt;p&gt;早速、各 Web サービスごとに対応状況を確認してみました。&lt;br&gt;
PC: ASUS Chromebook C100PA (Chrome OS 72.0.3626.49 Beta)&lt;br&gt;
Android: Google Pixel 3 (Android 9, Chrome for Android 71.0.3578.99)&lt;/p&gt;

&lt;h3&gt;Google&lt;/h3&gt;
&lt;p&gt;USB, NFC ともに対応済みでした。Android 端末からでも NFC を利用して認証できます。&lt;/p&gt;

&lt;h3&gt;Twitter&lt;/h3&gt;
&lt;p&gt;USB のみ対応済みでした。PC からであれば USB を使って認証できますが、Android からは次のように表示されてしまいます。&lt;/p&gt;
&lt;img src="https://2.bp.blogspot.com/-WYMjEddpHBg/XD2mzITN3II/AAAAAAABDRU/ZIuQFcbXDj4jCvT_0NkE7zdaW7sfFPcBgCKgBGAs/s1600/Screenshot_20190115-181555%257E2.png"&gt;

&lt;h3&gt;Microsoft&lt;/h3&gt;
&lt;p&gt;設定項目を見つけられませんでした。FIDO 2 でのログインに対応したというニュースを見かけたので、できると思ったのですが。&lt;/P&gt;

&lt;h3&gt;Amazon&lt;/h3&gt;
&lt;p&gt;これまた設定項目が見つかりませんでした。「Amazon セキュリティキー」で調べると商品ページしか出てこないんですね...&lt;/p&gt;

&lt;h3&gt;GitHub&lt;/h3&gt;
&lt;p&gt;01/16 追記&lt;br&gt;
GitHub を調べ忘れていました。GitHub でも USB, NFC ともに使用可能でした。&lt;/p&gt;

&lt;h2&gt;&lt;/h2&gt;
&lt;p&gt;(少なくとも僕の身近なところでは) 思ったよりきちんと使えるサービスが少ないということが分かりました。WebAuthn 流行ってほしいです。&lt;/p&gt;
</content>
    </entry>
    
    <entry>
      <title>8.8.8.8 が DNS-over-TLS に対応したようです</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2019-01-11/8888-dns-over-tls' />
      <id>https://blog.comame.xyz/entries/2019-01-11/8888-dns-over-tls</id>
      <updated>2019-01-11T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;8.8.8.8 で知られる Google Public DNS が &lt;a href="https://developers.google.com/speed/public-dns/docs/dns-over-tls" rel="noopener" target="_blank"&gt;DNS-over-TLS&lt;/a&gt; に対応したようです。既に Cloudflare の提供する 1.1.1.1 は対応済みなので、耳にしたことはあるかもしれません。&lt;br&gt;
    DNS への問い合わせを TLS で暗号化することで、応答の改ざんを防ぐことができます。&lt;/p&gt;

    &lt;p&gt;Android 9 Pie 以降を搭載している Android スマートフォンであれば、簡単に設定ができます。Windows や Mac OS 等では、OS 標準では DNS-over-TLS がサポートされないようです。&lt;/p&gt;

    &lt;p&gt;参照: &lt;a href="https://developers.google.com/speed/public-dns/docs/using" target=_blank" rel="noopener"&gt;Get Started | Google Public DNS&lt;/a&gt;&lt;/p&gt;


    &lt;h2&gt;設定方法&lt;/h2&gt;

    &lt;p&gt;「設定」アプリを開き、「ネットワークとインターネット」&gt;「詳細設定」&gt;「プライベート DNS」と進みます。&lt;br&gt;
    「プライベート DNS プロバイダのホスト名」に &lt;code&gt;dns.google&lt;/code&gt; と入力します。
    ブラウザを開き、Web サイトに正常にアクセスできたら完了です。&lt;/p&gt;

    &lt;p&gt;大事なことを書き忘れた: これは Pixel 3 での操作方法です。端末によって操作が異なるかもしれません。&lt;/p&gt;
</content>
    </entry>
    
    <entry>
      <title>Let's Encrypt でワイルドカード証明書を発行してみたお話</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2018-12-18/letsencrypt-wildcard' />
      <id>https://blog.comame.xyz/entries/2018-12-18/letsencrypt-wildcard</id>
      <updated>2018-12-18T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;Let's Encrypt でワイルドカード証明書を取得してみたら驚くほど簡単だったので、記事として残しておきます。&lt;/p&gt;

&lt;h2&gt;ワイルドカード証明書とは&lt;/h2&gt;

&lt;p&gt;ワイルドカード証明書とは、サブドメイン全てに一致する証明書です。例えば &lt;code&gt;*.example.com&lt;/code&gt; で取得した証明書は、&lt;code&gt;sub1.example.com&lt;/code&gt; や &lt;code&gt;sub2.example.com&lt;/code&gt; に一致します 。&lt;/p&gt;

&lt;p&gt;ワイルドカード証明書を使用することで、サブドメイン全てに個別の証明書を発行する手間が省けるため、管理がぐっと楽になります。&lt;/p&gt;

&lt;h2&gt;手順&lt;/h2&gt;

&lt;p&gt;今回は Dry Run を使用して、証明書の発行ができることを確認するだけにします。&lt;/p&gt;

&lt;p&gt;ワイルドカード証明書を発行するには、DNS を使用してドメインを検証する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo certbot certonly --dry-run &lt;b&gt;--manual --preferred-challenges dns-01&lt;/b&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;次に、発行先のドメインを聞かれます。&lt;br&gt;
&lt;code&gt;*.example.com&lt;/code&gt; のように入力するだけで、自動的にワイルドカード証明書として発行してくれます。便利ですね。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Please enter in your domain name(s) (comma and/or space separated)  (Enter 'c' to cancel):
*.example.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後にドメインの検証です。表示される案内に従って、DNS に TXT レコードを設定してください。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Please deploy a DNS TXT record under the name
_acme-challenge.example.com with the following value:

ランダムな文字列

Before continuing, verify the record is deployed.
Press Enter to Continue
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;DNS を設定したら、エンターキーを押すと証明書が発行されます。&lt;/p&gt;

&lt;h2&gt;注意事項・ハマったところ&lt;/h2&gt;

&lt;h3&gt;サブドメインにしか適用されない&lt;/h3&gt;

&lt;p&gt;先程は &lt;code&gt;*.example.com&lt;/code&gt; に対して証明書を発行しましたが、この証明書は &lt;code&gt;example.com&lt;/code&gt; には使用できません。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;example.com&lt;/code&gt; にも対応する証明書を作成するには、次のようにします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Please enter in your domain name(s) (comma and/or space separated)  (Enter 'c' to cancel):
&lt;b&gt;*.example.com example.com&lt;/b&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;証明書の自動更新がめんどい&lt;/h3&gt;

&lt;p&gt;ワイルドカード証明書を発行するときに &lt;code&gt;--manual&lt;/code&gt; を指定する必要がありましたが、この影響でいつもどおり &lt;code&gt;sudo certbot renew&lt;/code&gt; しても怒られてしまいます。シェルスクリプトを作成して、引数に渡す必要があるみたいです。&lt;/p&gt;

&lt;p&gt;デフォルトの certbot の設定では自動更新がなされないので、注意が必要です。&lt;/p&gt;
</content>
    </entry>
    
    <entry>
      <title>LINE Pay を Google Pay で使ってみた</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2018-11-30/line-pay-google-pay' />
      <id>https://blog.comame.xyz/entries/2018-11-30/line-pay-google-pay</id>
      <updated>2018-11-30T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;&lt;a href="http://pay-blog.line.me/archives/13246446.html"&gt;LINE Pay を Google Pay で使用できるようになった&lt;/a&gt;ので、早速使い始めてみました。今までスマホを使って支払いをしたことがなかったので、おサイフケータイを使うこと自体が初めてです。&lt;/p&gt;

&lt;h2&gt;便利なところ&lt;/h2&gt;

&lt;p&gt;まずはやはり、スマホだけを持って行けば支払いができるという点が最も便利です。近くのコンビニで買い物をしたいときなど、ちょっとした買い物のたびに財布を持ち出す必要がなくなりました。また、レジ前で焦って小銭を探す手間も無くなりました。&lt;br&gt;
また、物理的なカードも併用できるため、非接触型決済に対応していない店舗でも LINE Pay を使用して支払うことは可能です。&lt;/p&gt;


&lt;h2&gt;不便・改善してほしいところ&lt;/h2&gt;

&lt;p&gt;端末のロック時は決済をできないようにする機能が欲しいと思います。LINE Pay はプリペイドなので悪用された際の被害はあまり大きくありませんが、やはり気にすると気になるものです。最近は指紋認証が搭載されている Android 端末も増えてきているので、ぜひロックを追加してほしいですね。&lt;/p&gt;

&lt;h2&gt;&lt;/h2&gt;
&lt;p&gt;もしおサイフケータイに対応している端末をお持ちの方は、この機会にぜひ試してみてください。今なら LINE Pay を Google Pay に登録することで 1000 円分のクレジットを入手できます。&lt;br&gt;
今まで「Suica でいいじゃん」などと思っていましたが、常に持ち歩くスマホだけで済むというのはやはり便利だと思いました。&lt;/br&gt;
</content>
    </entry>
    
    <entry>
      <title>「Google Pixel まだ見ぬ世界展」に行ってきた</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2018-10-21/pixel-event' />
      <id>https://blog.comame.xyz/entries/2018-10-21/pixel-event</id>
      <updated>2018-10-21T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;表参道駅前で28日まで行われている、&lt;a href="http://designart.jp/designarttokyo2018/exhibitor/google/" target="_blank" rel="noopener"&gt;Google Pixel まだ見ぬ世界展&lt;/a&gt; に遊びに行ってきました。このイベントでは、11月1日に日本で発売される Google Pixel 3 の実機を試すことができます。&lt;br&gt;
    会場は Pixel のカメラ性能を実感できるような造りになっていましたが、カメラ以外にもかなり自由に端末に触れることができました。&lt;/p&gt;

    &lt;img src="https://1.bp.blogspot.com/-LlOgKux_tls/W8xIwBcmlGI/AAAAAAABAoo/2JKtsomi8Zo4a_HijCBkxNqtL754UycaQCKgBGAs/s1600/52_1540099167.jpg" alt="会場のロゴ写真"&gt;

    &lt;h2&gt;Pixel 3&lt;/h2&gt;

    &lt;h3&gt;サイズ感&lt;/h3&gt;
    &lt;p&gt;僕は今 ASUS Zenfone Go を使用しているのですが、手があまり大きくないため片手での操作があまり快適とはいえません。しかし、Pixel は横幅が少し小さめにとってあるため、片手での操作も楽々といった印象でした。&lt;br&gt;
    逆に、動画やゲームを楽しみたいという方は XL でないと少し物足りないと感じるかもしれません。最も、僕があまりゲームや動画の閲覧をスマホですることが余りないので、あまり自信をもって言うことはできないのですが。&lt;/p&gt;

    &lt;h3&gt;触り心地&lt;/h3&gt;
    &lt;p&gt;裏面もガラスでコーティングされているのですが、手に持った時に落としそうという感じはあまりしませんでした。ツルツルではあるのですが、手に吸い付くような感じとでも言いましょうか。&lt;/p&gt;

    &lt;h3&gt;物理ボタン&lt;/h3&gt;
    &lt;p&gt;端末を握った右側面に、電源ボタンと音量ボタンが付いています。かなりしっかりとしていて、強く押し込む必要がありました。&lt;br&gt;
    上から順に電源ボタン、音量ボタンの順についているのですが、個人的には逆向きのが好きです。&lt;/p&gt;

    &lt;h3&gt;カメラ&lt;/h3&gt;
    &lt;p&gt;売りにしているだけあり、やはりすごいなあという印象でした。適当に撮影しても、それなりに絵になる写真は撮れるんじゃないかと思います。カメラについてはあんまりわからない...&lt;br&gt;
    この記事の上のほうにある写真も、Pixel で撮影したものです。結構いい感じじゃないですか？&lt;/p&gt;

    &lt;h3&gt;Google Lens&lt;/h3&gt;
    &lt;p&gt;ついにこの機能が日本にもやってまいりました！ 今まで Google Lens を使ったことがないのですが、結構きちんと認識してくれました。この機能はいろいろと遊べそうなので、今後ほかの端末でも使えるようになるのかが楽しみです。&lt;/p&gt;

    &lt;h3&gt;Playground (AR)&lt;/h3&gt;
    &lt;p&gt;Pixel のカメラアプリに搭載されている、&lt;a href="https://developers.google.com/ar/" target="_blank" rel="noopener"&gt;ARCore&lt;/a&gt; を使用してマスコットや文字を空間上に配置することができる機能です。実際にこの機能を便利に使うかといわれると正直微妙ですが、床や壁を認識する精度は結構きちんとしている印象でした。少なくとも普通の部屋であれば問題なく使用できるかなという感じです。&lt;br&gt;
    空間に配置できるマスコットは Google Play Store からインストールして、自由に追加できるようです。&lt;/p&gt;

    &lt;h2&gt;まだ見ぬ世界展&lt;/h2&gt;

    &lt;p&gt;イベント会場は4階建てのビルになっていて、各階ごとにテーマが設定されています。それぞれの階でテーマに沿った体験をし、すべての階を回ると最後に飲み物がもらえます。&lt;br&gt;
    所要時間はおよそ30分程度ですが、同時に入れる人数が決まっている影響で、入場待ちに時間がかかります。&lt;/p&gt;

    &lt;h3&gt;1F Cave&lt;/h3&gt;
    &lt;p&gt;受付です。ここで端末を受け取り、上の階に上がっていきます。&lt;/p&gt;

    &lt;h3&gt;2F Forest&lt;/h3&gt;
    &lt;p&gt;この階では Google Lens を試すことができます。Pixel 3XL も展示してあります。&lt;/p&gt;

    &lt;h3&gt;3F Sky&lt;/h3&gt;
    &lt;p&gt;この階ではインカメラやポートレート撮影を試すことができます。&lt;/p&gt;

    &lt;h3&gt;4F Beyond&lt;/h3&gt;
    &lt;p&gt;この階では ARCore を使用したアプリケーションで遊ぶことができます。&lt;/p&gt;

    &lt;h2&gt;&lt;/h2&gt;
    &lt;p&gt;発売前に自由に Pixel を触ることができる良い機会でした。時間があればぜひ足を運んでみてください。&lt;br&gt;
    &lt;a href="http://designart.jp/designarttokyo2018/exhibitor/google/" target="_blank" rel="noopener"&gt;「Google Pixel まだ見ぬ世界展」の詳細を確認する&lt;/a&gt;&lt;/p&gt;
</content>
    </entry>
    
    <entry>
      <title>ブログの新テンプレートが完成！</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2018-10-20/new-template' />
      <id>https://blog.comame.xyz/entries/2018-10-20/new-template</id>
      <updated>2018-10-20T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;やっと Blogger 向けのテンプレートが完成しました！&lt;br&gt;
    &lt;a href="/p/test.html"&gt;サンプル&lt;/a&gt;&lt;/p&gt;
    &lt;p&gt;HTML も CSS も全て手書きです。Blogger のテンプレートは XML の単一ファイルに書かなくてはならない上に、公式ドキュメントが非常に乏しいので、本当に苦労しました。&lt;br&gt;できる限り記事自体を読みやすいようなデザインを心がけてみたのですが、デザインが全く分からない人間なのでご意見あったらどんどんお寄せください。&lt;/p&gt;
    &lt;p&gt;せっかく作ったので、このテンプレートを GitHub かどこかで公開したいなーと思ったりしてますが、広告の配置を一切考えていなかったり、一部の URL をハードコードしていたりで、誰かに使ってもらうのはちょっと難しいかな？&lt;/p&gt;
    &lt;p&gt;GitHub で見つけたこちらのサンプルコードには非常にお世話になったので、リンクをしておきます。これがなかったらテンプレート造りを諦めてた！&lt;br&gt;
    &lt;a href="https://github.com/lmatteis/blogger-skeleton"&gt;lmatteis/blogger-skeleton | GitHub&lt;/a&gt;&lt;/p&gt;
    &lt;p&gt;今後検索結果画面とかはもうちょっと何とかしたいと思ってます。&lt;/p&gt;
</content>
    </entry>
    
    <entry>
      <title>App Engine から Compute Engine に移行</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2018-08-19/ae-to-ce' />
      <id>https://blog.comame.xyz/entries/2018-08-19/ae-to-ce</id>
      <updated>2018-08-19T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;今まで Google App Engine Node.js Standard Environment (GAE/Node.js SE) で動かしていた &lt;a href="https://comame.xyz/" target="_blank" rel="noopener"&gt;comame.xyz&lt;/a&gt; を、Compute Engine に移しました。&lt;/p&gt;&lt;h2&gt;理由&lt;/h2&gt;&lt;p&gt;Nginx をいじってたら楽しくなってきちゃったから。&lt;/p&gt;&lt;h2&gt;感想&lt;/h2&gt;&lt;ul&gt;    &lt;li&gt;予想を遥かに上回るレベルで楽だった&lt;/li&gt;
    &lt;li&gt;環境依存するコードをほぼ書かなくて済むので、GAE/Node.js SE はいいぞ&lt;/li&gt;
    &lt;li&gt;Nginx 楽しい&lt;/li&gt;
    &lt;li&gt;Certbot (Let's Encrypt) すごい楽&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;環境&lt;/h2&gt;&lt;ul&gt;    &lt;li&gt;Google Compute Engine / f1-micro&lt;/li&gt;
    &lt;li&gt;Ubuntu 18.04&lt;/li&gt;
    &lt;li&gt;Nginx, Node.js&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;手順&lt;/h2&gt;&lt;ol&gt;    &lt;li&gt;GAE で動いていたコードを、Compute Engine に移す。&lt;/li&gt;
    &lt;li&gt;Nginx の設定ファイルにバーチャルホストの設定を追加する。&lt;/li&gt;
    &lt;li&gt;Node.js を systemd のサービスとして設定する。&lt;/li&gt;
    &lt;li&gt;Nginx の設定ファイルに Node.js へリクエスト回す処理を追記する。&lt;/li&gt;
    &lt;li&gt;Certbot で電子証明書を取得する。&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;コードを移す&lt;/h3&gt;&lt;p&gt;GAE/Node.js SE は GAE に依存する部分が少ないため、ほぼそのままコードを移すだけで完了。静的なファイルを配信する部分だけ、Nginx 側に処理を回すためにコードを削除。&lt;/p&gt;&lt;h3&gt;Nginx の設定をする&lt;/h3&gt;&lt;p&gt;こんな感じ。80 版ポートの方は省略。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# /etc/nginx/sites-enabled/comame.xyz

server {
    server_name comame.xyz;
    listen 443 http2 ssl;

    # ....
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;systemd に Node.js をサービスとして登録する&lt;/h3&gt;&lt;p&gt;多分落ちたときに自動再起動してくれると思う。まだ落ちてないからわからん。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# /etc/systemd/system/nodejs.service

[Unit]
Description=Node.js server

[Service]
WorkingDirectory=/home/hoge
Type=simple
ExecStart=/usr/bin/node /path/to/script.js
Restart=always
StandardOutput=syslog
StandardError=syslog
SyslogIdentifier=node
User=hoge
Group=hoge

[Install]
WantedBy=multi-user.target&lt;/code&gt;&lt;/pre&gt;&lt;code&gt;$ systemctl start nodejs.service&lt;/code&gt; でサービスを起動。&lt;br /&gt;
&lt;code&gt;$ systemctl enable nodejs.service&lt;/code&gt; で OS の起動時にサービスを起動するよう設定。&lt;br /&gt;
&lt;h3&gt;Nginx から Node.js にリクエストを回す&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# /etc/nginx/sites-enabled/comame.xyz

upstream node {
    # Node.js は 3000 番ポートで動かすことにした
    server 127.0.0.1:3000;
}

server {
    # ...
    location / {
        proxy_pass http://node;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Certbot で電子証明書を取得&lt;/h3&gt;&lt;p&gt;コマンド叩くだけで電子証明書が取得できるの、本当にすごいよね。あとは Nginx 側で証明書のパスを指定するだけ。&lt;/p&gt;&lt;code&gt;$ certbot certonly --nginx&lt;code&gt;&lt;/code&gt;&lt;/code&gt;
</content>
    </entry>
    
    <entry>
      <title>Gmail アドレスにおけるピリオドの扱い</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2018-07-28/gmail-period' />
      <id>https://blog.comame.xyz/entries/2018-07-28/gmail-period</id>
      <updated>2018-07-28T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;&lt;a href="https://productforums.google.com/forum/#!forum/gmail-ja" target="_blank" rel="noopener"&gt;Gmail ヘルプフォーラム&lt;/a&gt; で回答していると、それなりの頻度で次のような質問が届きます。&lt;/p&gt;&lt;blockquote&gt;ピリオドの有無が違うだけのメールアドレス宛のメールが、私にも届いています。これは他人宛のものではないのですか？&lt;/blockquote&gt;&lt;p&gt;Gmail の仕様では、@ より左側にあるピリオドの有無は無視されるようになっています。この仕様について、実験を交えて少し詳しく解説します。&lt;/p&gt;&lt;h2&gt;どのような仕様になっているの？&lt;/h2&gt;&lt;p&gt;以下のメールアドレスは、全て同じアカウントのメールアドレスとして扱われます。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;i&gt;example@gmail.com&lt;/i&gt;&lt;/li&gt;
    &lt;li&gt;&lt;i&gt;exam.ple@gmail.com&lt;/i&gt;&lt;/li&gt;
    &lt;li&gt;&lt;i&gt;e.x.a.m.p.l.e@gmail.com&lt;/i&gt;&lt;/li&gt;
    &lt;/ul&gt;&lt;h2&gt;他の人に届くことはないのか？&lt;/h2&gt;&lt;p&gt;A. ありません。&lt;/p&gt;&lt;h3&gt;実験&lt;/h3&gt;&lt;p&gt;では、実験をしてみましょう。まずは、&lt;a href="https://gmail.com" target="_blank" rel="noopener"&gt;Gmail&lt;/a&gt; にアクセスし、新規メール作成ダイアログを開いてください。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;ご自身の Gmail アドレスに適当にピリオドを挟んで送信してみる&lt;br /&gt;
    例: &lt;i&gt;example@gmail.com&lt;/i&gt; → &lt;i&gt;exam.ple@gmail.com&lt;/i&gt;&lt;/li&gt;
    &lt;li&gt;ご自身の Gmail アドレスから適当にピリオドを外して送信してみる&lt;br /&gt;
    例: &lt;i&gt;your.address@gmail.com&lt;/i&gt; → &lt;i&gt;youraddress@gmail.com&lt;/i&gt;&lt;/li&gt;
    &lt;/ol&gt;&lt;h3&gt;解説&lt;/h3&gt;&lt;p&gt;手順 1 と 2 どちらの場合も、自分の受信トレイにメールが届いたはずです。&lt;br /&gt;
    Gmail では、@ より左側にあるピリオドは無視され、全て同じアカウントのメールアドレスとして扱われます。つまり、&lt;b&gt;ピリオドがあろうがなかろうが、全て同じ人に届く&lt;/b&gt;ということがわかります。&lt;/p&gt;&lt;h2&gt;他の人が使っている可能性は？&lt;/h2&gt;&lt;p&gt;A. ありません。&lt;/p&gt;&lt;h3&gt;実験&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;Google アカウントからログアウトする&lt;/li&gt;
    &lt;li&gt;再び&lt;a href="https://accounts.google.com/signin" target="_blank" rel="noopener"&gt;ログイン画面&lt;/a&gt;を開く&lt;/li&gt;
    &lt;li&gt;普段ログインしているメールアドレスに、適当にピリオドを挟んでログインしてみる&lt;/li&gt;
    &lt;li&gt;普段ログインしているメールアドレスから、適当にピリオドを外してログインしてみる&lt;/li&gt;
    &lt;li&gt;&lt;a href="https://accounts.google.com/signup" target="_blank" rel="noopener"&gt;アカウントの作成画面&lt;/a&gt;を開く&lt;/li&gt;
    &lt;li&gt;Gmail アドレスの入力欄に、普段ログイン時に使用している Gmail アドレスを入力し、アカウントを作成しようとしてみる&lt;/li&gt;
    &lt;li&gt;普段ログイン時に使用している Gmail アドレスに適当にピリオドを挟んで入力してみる&lt;/li&gt;
    &lt;li&gt;普段ログイン時に使用している Gmail アドレスから適当にピリオドを外して入力してみる&lt;/li&gt;
    &lt;/ol&gt;&lt;h3&gt;解説&lt;/h3&gt;&lt;p&gt;手順 3 と 4 どちらでも、ご自身のアカウントにログインできることが確認できたはずです。&lt;br /&gt;
    また、手順 6, 7, 8 では全て「すでに使用されています」と警告が表示されたはずです。&lt;br /&gt;
    つまり、&lt;b&gt;ピリオドの有無が異なるだけの Gmail アドレスは、同一のアカウントとして扱われる&lt;/b&gt;ということがわかります。同一のアカウントなわけですから、他人が使用している可能性はありません。&lt;/p&gt;&lt;h2&gt;まとめ&lt;/h2&gt;以上より、Gmail では @ より左側にあるピリオドの有無は無視され、同一のアカウント・宛先として扱われていることがわかります。&lt;br /&gt;
</content>
    </entry>
    
    <entry>
      <title>Gmail のフォローアップ機能を停止する</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2018-07-27/stop-gmail-followup' />
      <id>https://blog.comame.xyz/entries/2018-07-27/stop-gmail-followup</id>
      <updated>2018-07-27T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;新デザインの Gmail には、返信し忘れたメールや対応が必要なメールを判別し、受信トレイの先頭に表示してくれる機能が追加されました。&lt;br /&gt;
    このフォローアップ機能は便利ですが、一方で不要な方もいるでしょう。この機能を停止する方法を紹介します。&lt;/p&gt;&lt;h2&gt;モバイル&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;Gmail アプリを開く&lt;/li&gt;
    &lt;li&gt;左上のメニューアイコンをタップして、サイドバーを開く&lt;/li&gt;
    &lt;li&gt;最下部の「設定」を開き、フォローアップ機能を停止したいアカウントを選択する&lt;/li&gt;
    &lt;li&gt;「アクションの提案」セクション内の「返信とフォローアップ」を開く&lt;/li&gt;
    &lt;li&gt;停止したいもののチェックボックスを外す&lt;/li&gt;
    &lt;/ol&gt;&lt;h2&gt;デスクトップ&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a href="https://gmail.com/" target="_blank" rel="noopener"&gt;Gmail&lt;/a&gt; を開く&lt;/li&gt;
    &lt;li&gt;右上の歯車アイコンを押し、設定を開く&lt;/li&gt;
    &lt;li&gt;「概要」タブの「アクションの提案」セクションに移動する&lt;/li&gt;
    &lt;li&gt;チェックボックスを外す&lt;/li&gt;
    &lt;/ol&gt;&lt;p&gt;有効にする手順もこれと同様です。&lt;/p&gt;
</content>
    </entry>
    
    <entry>
      <title>#31DaysOfKotlin Week 1 日本語訳</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2018-04-30/31daysofkotlin' />
      <id>https://blog.comame.xyz/entries/2018-04-30/31daysofkotlin</id>
      <updated>2018-04-30T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;この記事は、&lt;a href="https://twitter.com/androiddev" rel="noopener" target="_blank"&gt;@AndroidDev&lt;/a&gt; による &lt;a href="https://medium.com/google-developers/31daysofkotlin-week-1-recap-fbd5a622ef86" target="_blank" rel="noopener"&gt;#31DaysOfKotlin — Week 1 Recap&lt;/a&gt; を&lt;strong&gt;勝手に&lt;/strong&gt;日本語訳したものです。&lt;br /&gt;
    基本的な文法からちょっとした TIPS まで様々なことが紹介されているので、知らないものがあったらぜひ使ってみてください。&lt;/p&gt;&lt;h2&gt;Day 1: Elvis Operator (エルビス演算子)&lt;/h2&gt;&lt;p&gt;Null チェックをよりスマートにするには、エルビス演算子を使ってみましょう。&lt;br /&gt;
    Null を別の値に置き換えたり、あるいは&lt;code&gt;return&lt;/code&gt;したりもできます！&lt;br /&gt;
    Docs: &lt;a href="https://kotlinlang.org/docs/reference/null-safety.html#elvis-operator" target="_blank" rel="noopener"&gt;Elvis Operator&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;val name: String = person.name ?: “unknown”
    val age = person.age ?: return&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a class="name" name="day2"&gt;&lt;/a&gt;Day 2: String Templates (文字列テンプレート)&lt;/h2&gt;&lt;p&gt;文字列に変数を埋め込むには、変数名の前に&lt;code&gt;$&lt;/code&gt;を入れましょう。&lt;br /&gt;
    式を入れるには&lt;code&gt;${expression}&lt;/code&gt;のようにしてください。&lt;br /&gt;
    Docs: &lt;a href="https://kotlinlang.org/docs/reference/basic-types.html#string-templates" target="_blank" rel="noopener"&gt;String Templates&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;val language = “Kotlin”

    // “Kotlin has 6 characters”
    val text = “$language has ${language.length} characters”&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Day 3: Destructing Declarations (分解宣言)&lt;/h2&gt;&lt;p&gt;&lt;a href="https://github.com/android/kotlin-extensions" target="_blank" rel="noopener"&gt;Android KTX&lt;/a&gt; では、色の成分値を割り当てるのに分解宣言を使用します。&lt;br /&gt;
    自作のクラス内で分割代入を使用できますし、既存のクラスを拡張して追加することも可能です。(&lt;a href="http://sys1yagi.hatenablog.com/entry/2016/06/05/171132" target="_blank" rel="noopener"&gt;日本語名称について参考にした記事&lt;/a&gt;)&lt;br /&gt;
    Docs: &lt;a href="https://kotlinlang.org/docs/reference/multi-declarations.html" target="_blank" rel="noopener"&gt;Destructing Declarations&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 色要素
    val (red, green, blue) = color

    // 四角形
    val (left, top, right, bottom) = rect

    // 座標
    val (x, y) = point&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a class="name" name="day4"&gt;&lt;/a&gt;Day 4: When Expression (When 式)&lt;/h2&gt;&lt;p&gt;条件分岐をよりよく書くには&lt;code&gt;when&lt;/code&gt;式を使ってみましょう。&lt;br /&gt;
    Kotlin の&lt;code&gt;when&lt;/code&gt;式は、文字列リテラルや Enum、Range など何にでも使用できます！任意の関数を呼ぶことも可能です。&lt;br /&gt;
    Docs: &lt;a class="markup--anchor markup--p-anchor" href="https://kotlinlang.org/docs/reference/control-flow.html#when-expression" target="_blank" rel="nofollow noopener" data-href="https://kotlinlang.org/docs/reference/control-flow.html#when-expression"&gt;When&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;class Train(val cargo: Number?) {
        override fun toString(): String {
            return when (cargo) {
                null, 0 -&gt; "empty"
                1 -&gt; "tiny"
                in 2..10 -&gt; "small"
                is Int -&gt; "big inty"
                else -&gt; "$cargo"
            }
        }
    }&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Day 5: For loops, range expressions and destructing (For ループと Range、分解宣言)&lt;/h2&gt;&lt;p&gt;&lt;code&gt;for&lt;/code&gt;ループは Kotlin の Range や分解宣言を使うと便利です。&lt;br /&gt;
    Docs: &lt;a class="markup--anchor markup--p-anchor" href="https://kotlinlang.org/docs/reference/ranges.html" target="_blank" rel="nofollow noopener" data-href="https://kotlinlang.org/docs/reference/ranges.html"&gt;Ranges&lt;/a&gt;, &lt;a class="markup--anchor markup--p-anchor" href="https://kotlinlang.org/docs/reference/multi-declarations.html#destructuring-declarations" target="_blank" rel="nofollow noopener" data-href="https://kotlinlang.org/docs/reference/multi-declarations.html#destructuring-declarations"&gt;Destructuring&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 1 から 100　まで
    for(i in 1..100) {…}

    // 1 から 100 まで降順
    for(i in 100 downTo 1){…}

    // 配列の要素を1つ飛ばしで
    val array = arrayOf(“a”, “b”, “x”)
    for(i in 1 until array.size step 2 ){…}

    // 配列の要素を分解宣言で取り出す
    for((index, element) in array.withIndex()) {…}

    // Map の要素を分解宣言で取り出す
    val map = mapOf(1 to “one”, 2 to “two”)
    for( (key, value) in map){…}&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;a class="name" name="day6"&gt;&lt;/a&gt;Day 6: Properties (プロパティ)&lt;/h2&gt;&lt;p&gt;Kotlin では、クラスのプロパティのゲッターとセッターが自動生成されます。必要に応じてカスタマイズすることも可能です。&lt;br /&gt;
    Docs: &lt;a class="markup--anchor markup--p-anchor" href="https://kotlinlang.org/docs/reference/properties.html" target="_blank" rel="nofollow noopener" data-href="https://kotlinlang.org/docs/reference/properties.html"&gt;Properties&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;class User {
        // properties
        val id: String = “” // 変更禁止。ゲッターのみ

        var name: String = “” // デフォルトのゲッターとセッター

        var surname: String = “” // カスタムゲッターとデフォルトのセッター
          get() = surname.toUpperCase() // custom getter declaration

        var email: String = “” // デフォルトのゲッターとカスタムセッター
          set(value) { // カスタムセッターの宣言
              // “value” = セッターのパラメータ
              // “field” = 自動生成されるバッキングフィールド
              if(isEmailValid(value)) field = value
          }
    }&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Day 7: Data Classes and equality (データクラスと等価性)&lt;/h2&gt;&lt;p&gt;データの保持だけが目的であれば、データクラスを使ってみましょう。構造的等価性 (Structual Equality) をチェックする&lt;code&gt;equals()&lt;/code&gt;や&lt;code&gt;hashCode()&lt;/code&gt;,&lt;code&gt;toString()&lt;/code&gt;,&lt;code&gt;copy()&lt;/code&gt;などの関数が自動生成されます。&lt;br /&gt;
    Docs: &lt;a class="markup--anchor markup--p-anchor" href="https://kotlinlang.org/docs/reference/data-classes.html#data-classes" target="_blank" rel="nofollow noopener" data-href="https://kotlinlang.org/docs/reference/data-classes.html#data-classes"&gt;Data Classes&lt;/a&gt;, &lt;a class="markup--anchor markup--p-anchor" href="https://kotlinlang.org/docs/reference/equality.html" target="_blank" rel="nofollow noopener" data-href="https://kotlinlang.org/docs/reference/equality.html"&gt;Equality&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;data class User(
        val name: String,
        val email: String,
        val address: Address,
        …
    )
    public class UserListDiffCallback: DiffUtil.Callback() {
        override fun areContentsTheSame(
             oldItemPosition: Int,
             newItemPosition: Int
        ): Boolean {
        // 自動生成された比較メソッドを使用
        return newUserList[newItemPosition] ==
               oldUserList[oldItemPosition])
    }&lt;/code&gt;&lt;/pre&gt;
</content>
    </entry>
    
    <entry>
      <title>新しいデザインの Gmail がリリースされました</title>
      <link rel='alternate' href='https://blog.comame.xyz/entries/2018-04-26/new-design-gmail-released' />
      <id>https://blog.comame.xyz/entries/2018-04-26/new-design-gmail-released</id>
      <updated>2018-04-26T00:00:00Z</updated>
      <content type='html'>&lt;p&gt;新しいデザインの Gmail が、昨日リリースされました！マテリアルデザインが適用されたほか、カレンダーや ToDo リストが使いやすくなっているようです。&lt;br /&gt;
    &lt;a href="https://japan.googleblog.com/2018/04/gmail.html" target="_blank" rel="noopener"&gt;新しい Gmail をお試しください。- Google Japan Blog&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;変更点&lt;/h2&gt;&lt;h3&gt;スヌーズ機能が追加された&lt;/h3&gt;&lt;p&gt;この機能は &lt;a href="https://inbox.google.com" target="_blank" rel="noopener"&gt;Inbox by Gmail&lt;/a&gt; からの逆輸入ですね。メールを一旦受信トレイから非表示 (アーカイブ) にし、指定した日付に再び受信トレイに戻す機能です。&lt;/p&gt;&lt;h3&gt;メールに対しての操作が簡単になった&lt;/h3&gt;&lt;p&gt;これまた Inbox からの逆輸入です。メールの一覧画面から、今までより簡単にアーカイブ、削除、移動などの操作が行えるようになりました。マウスカーソルをメールに合わせると、下の画像のようなアイコンが表示されます。&lt;/p&gt;&lt;img src="https://2.bp.blogspot.com/-IMmNaD33EcI/W8oUwVKCbcI/AAAAAAABAYQ/QaRXXsRJrnMRb8beuxaGIDIvLjY2fDXxACLcBGAs/s1600/%25E3%2582%25B3%25E3%2583%25A1%25E3%2583%25B3%25E3%2583%2588.png"/&gt;&lt;br /&gt;
    &lt;h3&gt;添付ファイルが見やすくなった&lt;/h3&gt;&lt;p&gt;メールに添付ファイルがある場合、メールの一覧画面に今までよりわかりやすく表示されるようになりました。1つ面白いのが、Google ドキュメントのファイルでも添付ファイルとして表示される点です。これらのファイルは、Gmail 以外から見るとただの URL としてしか表示されません。Google だからこその連携といえますね。&lt;/p&gt;
    &lt;h3&gt;Keep やカレンダー、ToDo リストがサイドバーに表示されるようになった&lt;/h3&gt;&lt;p&gt;Google Keep や Google カレンダー、ToDo リストが画面の右側に常駐するようになりました。これらの機能をよく使う人にとっては、アクセスがかなり楽になると思います。&lt;/p&gt;&lt;h3&gt;ローディングアニメーションがちょっとおしゃれになった&lt;/h3&gt;&lt;p&gt;小さな変更点ですが、個人的にはかなり気に入っています。ロード時に表示される Gmail アイコンの封筒が スルッ とアニメーションするようになりました。&lt;/p&gt;&lt;img src="https://4.bp.blogspot.com/-48suJpjRAe4/W8c80H2uGQI/AAAAAAABAXA/BcDabZoczOYidXo8f0ACvP3g1CyOKiAQgCLcBGAs/s1600/ezgif-1-51157c01d8.gif"&gt;&lt;br /&gt;
    &lt;h2&gt;移行方法&lt;/h2&gt;&lt;p&gt;受信トレイの右上に表示されている歯車アイコンをクリックし、「新しい Gmail を試す」を選択してください。新デザインに切り替えたあとでも、同様の手順でいつでも従来のデザインに戻すことができます。&lt;/p&gt;&lt;h2&gt;感想&lt;/h2&gt;&lt;p&gt;今回のアップデートは、Inbox からの逆輸入が多かったように思います。どれも使いやすい機能ですので、ぜひアップデートしてみてください。&lt;/p&gt;
</content>
    </entry>
    
    </feed>