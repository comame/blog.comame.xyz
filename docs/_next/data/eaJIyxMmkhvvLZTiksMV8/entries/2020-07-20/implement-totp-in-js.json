{"pageProps":{"entry":{"entry":"implement-totp-in-js","title":"TOTP をフルスクラッチした","date":"2020-07-20","tags":["note"],"type":"md"},"text":"<p>JavaScript で TOTP を実装してみたので、その実装メモなど。</p>\n<p><a href=https://github.com/comame/TOTP target='_blank' rel='noopener'>https://github.com/comame/TOTP</a></p>\n<h2>TOTP</h2>\n<p>RFC 6238: TOTP: Time-Based One-Time Password Algorithm で規定される。Google Authenticator アプリなどを使って時刻ベースで生成される (大抵) 6 桁のワンタイムパスワードであり、2 要素認証に用いられる。</p>\n<p>疑似コードで次のように表される。</p>\n<pre>\n<code>K: 共有シークレット、QR コードとかで読み込むやつ</code>\n<code>X: ステップ秒。大抵 30 秒。この値の周期でトークンが切り替わる</code>\n<code>T0: Unix Time の開始秒。大抵 0</code>\n<code></code>\n<code>T = (Current Unix Time - T0) / X) as Integer</code>\n<code></code>\n<code>TOTP(K, T) = HOTP(K, T) = Truncate(HMAC-SHA-1(K, T))</code>\n</pre><p>トークンの生成アルゴリズムには HOTP を使用する。</p>\n<p>のちに記述するように、HOTP では T の値が 32-bit までしかサポートされていないため、4.2 節では 32-bit より大きい整数をサポートするように規定されている。具体的にどう実装するのかは記述されていないので、Google Authenticator の実装などを見るのが良いと思われる。</p>\n<h2>HOTP</h2>\n<p>RFC 4226: HOTP: An HMAC-Based One-Time Password Algorithm で規定される。カウンターベースのワンタイムパスワード。</p>\n<pre>\n<code>K: 共有シークレット</code>\n<code>C: カウンター。8-byte の整数</code>\n<code>HS: 20-byte</code>\n<code>S: 31-bit</code>\n<code>D: 桁数が Digit の HOTP トークン</code>\n<code></code>\n<code>DT(HS: bytes[20])</code>\n<code>    OffsetBits = HS[19] & 0xF // HS[19] の下位 4-bit</code>\n<code>    Offset = OffsetBits as Integer // 0 <= offset<= 15</code>\n<code>    P = HS[Offset]...HS[Offset + 3]</code>\n<code>    return P & 0x7FFFFFFF // 下位 31-bit</code>\n<code></code>\n<code>HS = HMAC-SHA-1(K, C)</code>\n<code>S = DT(HS)</code>\n<code>D = (S as Integer) mod 10^Digit</code>\n</pre><p>RFC の 5.4 節の例は次の通りである。</p>\n<pre>\n<code>HS = {</code>\n<code>    1F, 86, 98, 69, 0E,</code>\n<code>    02, CA, 16, 61, 85,</code>\n<code>    50, EF, 7F, 19, DA,</code>\n<code>    8E, 94, 5B, 55, 5A</code>\n<code>}</code>\n<code></code>\n<code>OffsetBits = 0xA</code>\n<code>Offset = 10</code>\n<code>P = 0x50EF7F19</code>\n<code></code>\n<code>S = 0x50EF7F19 & 0x7FFFFFFF = 0x50EF7F19</code>\n<code>D = 872921</code>\n</pre><h2>HMAC</h2>\n<p><a href=https://www.ipa.go.jp/security/rfc/RFC2104JA.html target='_blank' rel='noopener'>https://www.ipa.go.jp/security/rfc/RFC2104JA.html</a> に日本語での解説がある。</p>\n<pre>\n<code>H: ハッシュ関数</code>\n<code>K: シークレット</code>\n<code>M: メッセージ</code>\n<code></code>\n<code>ipad = 0x3636...</code>\n<code>opad = 0x5C5C...</code>\n<code>// ipad, opad の長さはハッシュ関数のブロック長 (SHA-1 の場合 512-bit) と同一</code>\n<code></code>\n<code>||: ビットの連結</code>\n<code></code>\n<code>HMAC(K, M) = H((K xor opad) || H((K xor ipad) || M))</code>\n</pre><p>K と opad, ipad とで排他的論理和をとっていることから分かるように、K の長さもハッシュ関数のブロック長と同一にする必要がある。K は入力値であることから、長さを揃えるために次のような処理を順に行う。</p>\n<p>K の長さがブロック長より大きい場合、K をハッシュ関数に通す。K の長さがブロック長より小さい場合、ブロック長と同一になるまで末尾に 0 を追加する。</p>\n<h2>SHA-1</h2>\n<p><a href=https://www.ipa.go.jp/security/rfc/RFC3174JA.html target='_blank' rel='noopener'>https://www.ipa.go.jp/security/rfc/RFC3174JA.html</a> に日本語での解説がある。</p>\n<p>まずはメッセージのパディングを行い、メッセージ長を 512-bit の倍数にする。オリジナルのメッセージ長が 512-bit の倍数であった時にもパディングは行う。パディングは次の手順で行う。</p>\n<ul>\n<li>末尾に 1-bit の 1 を付加する</li>\n<li>メッセージ長が mod 512-bit = 448 になるまで 0 を末尾に付加する</li>\n<li>オリジナルのメッセージ長を 64-bit で付加する</li>\n</ul>\n<p>次の関数を定義する。</p>\n<pre>\n<code>f(t; B, C, D) = (B & C) | ((~B) & D); (0 <= t <= 19)</code>\n<code>f(t; B, C, D) = B ^ C ^ D; (20 <= t <= 39)</code>\n<code>f(t; B, C, D) = (B & C) | (B & D) | (C & D) (40 <= t <= 59)</code>\n<code>f(t; B, C, D) = B ^ C ^ D; (60 <= t <= 79)</code>\n<code></code>\n<code>K(t) = 0x5A827999; (0 <= t <= 19)</code>\n<code>K(t) = 0x6ED9EBA1; (20 <= t <= 39)</code>\n<code>K(t) = 0x8F1BBCDC; (40 <= t <= 59)</code>\n<code>K(t) = 0xCA62C1D6; (60 <= t <= 79)</code>\n<code></code>\n<code>S^N(n) = (M << n) | (M >> (32 - n)) // 循環左シフト</code>\n<code>A + B = (A + B) mod (2 ** 32)</code>\n</pre><p>複数の計算方法があるようだが、今回は次の方法で計算した。</p>\n<pre>\n<code>M: 512-bit ごとに区切ったメッセージ</code>\n<code></code>\n<code>H0 = 0x67452301</code>\n<code>H1 = 0xEFCDAB89</code>\n<code>H2 = 0x98BADCFE</code>\n<code>H3 = 0x10325476</code>\n<code>H4 = 0xC3D2E1F0</code>\n<code></code>\n<code>for each M(i)</code>\n<code>    W[16] = M(i) // M(i) を 32-bit ごとに分割する</code>\n<code></code>\n<code>    for t from 16 to 79</code>\n<code>        W[t] = S^1(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16])</code>\n<code></code>\n<code>    A = H0; B = H1; C = H2; D = H3; E = H4</code>\n<code></code>\n<code>    for t from 0 to 79</code>\n<code>        TMP = S^5(A) + f(t; B, C, D) + E + W[t] + K(t)</code>\n<code>        E = D; D = C; C = s^30(B); A = TMP</code>\n<code></code>\n<code>    H0 += A; H1 += B; H2 += C; H3 += D; H4 += E</code>\n<code></code>\n<code>// H0 H1 H2 H3 H4 をこの順で並べる</code>\n</pre><h2>実装で苦しんだところ (大体うっかり)</h2>\n<h3>HOTP</h3>\n<p>C は 8-byte 整数。</p>\n<h3>HMAC</h3>\n<p>ハッシュ関数に SHA-1 を使用する場合、ブロック長は 64-byte、出力長は 20-byte であることから、K にハッシュを通した後に 0 を追加する処理を行う必要がある。</p>\n<h3>SHA-1</h3>\n<p>(追記あり) 左循環シフト。<code>(n: number, x: number) =&gt; (x &lt;&lt; n) | (x &gt;&gt; (32 - n))</code> と素直に書くと、x は 32-bit 整数、<code>0 &lt;= n &lt; 32</code> であることからオーバーフローする。</p>\n<h2>参考にしたもの</h2>\n<dl>\n    <dt>IPA の RFC 日本語訳</dt>\n    <dd>HMAC と SHA-1 の実装</dd>\n    <dt>Golang のソースコード</dt>\n    <dd>テストケースや各アルゴリズムの実装。読みやすい。</dd>\n    <dt>RFC</dt>\n    <dd>テスト用のサンプルケースが Appendix に書いてあることを初めて知った</dd>\n</dl>\n\n\n<h2>左循環シフトの高速化</h2>\n<p><a href=https://github.com/comame/TOTP/compare/e495732d9156e805c78ff2626e95f09301123b32...361549fc64a207bcc402f48f802ee4d68b61cac6 target='_blank' rel='noopener'>https://github.com/comame/TOTP/compare/e495732d9156e805c78ff2626e95f09301123b32...361549fc64a207bcc402f48f802ee4d68b61cac6</a></p>\n<p>オーバーフローをしないためにビットの配列に変換してシフト操作をしていたものを、number のまま計算できるように書き換えた。オーバーフローを起こさないため、32-bit 整数を 8-bit ずつに区切り、場合分けした。また、シフト演算子を使うとオーバーフローを起こすため、掛け算と割り算でシフト演算子と同等の計算を行うようにした。</p>\n<p>次のようなコードで 10 回ずつ計測しそれぞれ平均をとったところ、高速化前は 616 ms、高速化後は 5 ms となった。</p>\n<p>また、SHA-1 の計算自体も、おおむね半分から 5 分の 1 程度の実行時間に短縮された。</p>\n<pre>\n<code>const t = Date.now()</code>\n<code>for (let i = 0; i < 100000; i +=1) circularShift(16, 0x12345678)</code>\n<code>console.log(Date.now() - t)</code>\n</pre><pre>\n<code>測定結果</code>\n<code></code>\n<code>高速化前 [ms]</code>\n<code>    608 605 611 598 612 599 698 605 612 611</code>\n<code>高速化後 [ms]</code>\n<code>    4   4   6   4   5   5   5   4   5   5</code>\n</pre>"},"__N_SSG":true}