{"pageProps":{"entry":{"entry":"blog-tech","title":"ブログシステムを新しくした (技術面)","date":"2020-03-11","tags":["Blog"],"type":"md"},"text":"<p>このブログの技術的な要素を解説する。最終的に静的なファイルとして出力されるまでの流れは、概ね次のようになる。</p>\n<ol>\n<li>ブラウザ上の JavaScript で記事データを読み、ページを生成する</li>\n<li>Puppeteer でスクリプト実行後のページを保存する</li>\n<li>記事データを読み、サイトマップやフィードを書き出す</li>\n</ol>\n<p>理念として、ビルドをする前でも完全なページが閲覧できるようにすることを目指した。</p>\n<h2>記事データ</h2>\n<ul>\n<li><a href=https://github.com/comame/blog.comame.xyz/blob/master/archives/entries.json target='_blank' rel='noopener'>archives/entries.json</a></li>\n</ul>\n<p>年毎にディレクトリを分けることにした。</p>\n<h3><code>archives/entries.json</code></h3>\n<p>すべての記事のメタデータを保存する。ページを生成するときに参照する。</p>\n<ul>\n<li><code>entry</code>: <code>.html</code> 拡張子を付けるとファイル名と対応する。</li>\n<li><code>title</code>: ページに表示されるタイトル。</li>\n<li><code>date</code>: <code>yyyy-mm-dd</code> の形式。</li>\n<li><code>tags</code>: 文字列の配列。</li>\n</ul>\n<h2>フロントエンドでのページ生成</h2>\n<ul>\n<li><a href=https://github.com/comame/blog.comame.xyz/blob/master/index.html target='_blank' rel='noopener'>index.html</a></li>\n<li><a href=https://github.com/comame/blog.comame.xyz/blob/master/assets/js/app.js target='_blank' rel='noopener'>assets/js/app.js</a></li>\n</ul>\n<p>記事データを読み込んで、ページを生成する。後に Puppeteer でスクレイピングする際にページが生成し終わったことを確認できるよう、ページの生成後に特別な <code>&lt;meta&gt;</code> タグを埋め込んだ。</p>\n<p>今回は自前のルーターライブラリを用いたが、React などを使っても問題ないはず。</p>\n<h3>記事の一覧・タグ</h3>\n<p><code>entries.json</code> を Fetch API で取得し、該当するページの情報を得た。</p>\n<h3>記事ページ</h3>\n<p><code>entries.json</code> から記事の HTML のファイルパスを取得し、HTML を埋め込んだ。</p>\n<h2>Node.js を使ったビルド</h2>\n<ul>\n<li><a href=https://github.com/comame/blog.comame.xyz/blob/master/build.js target='_blank' rel='noopener'>build.js</a></li>\n<li><a href=https://github.com/comame/blog.comame.xyz/blob/master/build/comameito_puppeteer-nginx target='_blank' rel='noopener'>build/comameito_puppeteer-nginx</a></li>\n</ul>\n<p>基本的には <code>main()</code> を追っていけばよい。Puppeteer が確実に動くようにするため、<a href=https://github.com/puppeteer/puppeteer/blob/master/docs/troubleshooting.md#chrome-headless-doesnt-launch-on-unix target='_blank' rel='noopener'>Puppeteer に必要な依存関係</a>, Nginx, Node.jsをインストールした Docker コンテナを事前に用意した。</p>\n<h3><code>buildMarkdown()</code></h3>\n<p><a href=https://www.npmjs.com/package/markdown-it target='_blank' rel='noopener'>markdown-it</a> を使って、Markdown で書かれた記事を HTML に変換する。</p>\n<p>[追記] API がよりシンプルで、カスタマイズが簡単な <a href=https://www.npmjs.com/package/marked target='_blank' rel='noopener'>marked</a> を使うように変更した。それにより、外部リンクは新しいタブで開くようにした。</p>\n<p>[追記] 静的ビルド前でも完全なページが表示できるよう、Markdowm のビルドをフロントエンドに移動した。</p>\n<h3><code>copyAssets()</code></h3>\n<p><code>assets/</code> を再帰的に潜っていって、画像や CSS、JavaScript などのファイルをそのままコピーする。</p>\n<h3><code>crawl()</code></h3>\n<p><a href=https://github.com/puppeteer/puppeteer target='_blank' rel='noopener'>Puppeteer</a> を用いて、実際に見えている Web ページを JavaScript を用いない静的な HTML ファイルに変換した。<code>index.html</code> から内部リンクをすべて拾っていく形にしている。Puppeteer では Browser Context でのスクリプトも簡単に実行できるため、あまり苦労しなかった。</p>\n<p><code>load</code> イベントと JavaScipt の実行が完了するタイミングが一致しない (非同期処理) ため、スクリプトでのページ生成が終わった時点で追加される <code>meta</code> タグを待機してからページを保存する (<a href=https://github.com/puppeteer/puppeteer/blob/v2.1.1/docs/api.md#pagewaitforselectorselector-options target='_blank' rel='noopener'><code>async page.waitForSelector(selector)</code></a> が便利だった)。</p>\n<p>無限ループを防ぐために、保存済みページの URL の Set を受け取るようにした。これは後のサイトマップ生成でも活用されることになった。</p>\n<p>読み込みの高速化のため、ページ生成用の JavaScript を削除し、CSS をインラインに展開している。</p>\n<h3><code>createSitemap()</code></h3>\n<p><code>crawl()</code> で作成した保存済みページの URL のセットから、サイトマップを書き出した。今回は URL を列挙しただけのテキストファイルにした。</p>\n<h3><code>createFeed()</code></h3>\n<p><code>entries.json</code> から、Atom のフィードを生成する。</p>\n<p>[追記] Markdown のビルドが移動した影響で、Puppeteer を使って記事の内容を拾うようにした。</p>\n<h2>GitHub Actions</h2>\n<ul>\n<li><a href=https://github.com/comame/blog.comame.xyz/blob/master/.github/workflows/build.yml target='_blank' rel='noopener'>.github/workflows/build.yml</a></li>\n</ul>\n<p>Node.js のビルドは、GitHub Actions で自動的に行うことにした。ビルド用の Docker コンテナを起動し、Node.js でビルドし、生成物を commit するようになっている。</p>\n<h2>公開</h2>\n<p>GitHub Pages を使うようにした。GitHub Actions でのビルドが終わり、レポジトリに push されると自動的に反映される。</p>\n"},"__N_SSG":true}